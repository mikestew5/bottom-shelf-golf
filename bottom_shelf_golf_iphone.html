<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bottom Shelf Golf</title>

    <!-- Link Preview (iMessage / social) -->
    <meta property="og:title" content="Bottom Shelf Golf">
    <meta property="og:description" content="Wobbly putt-putt with the boys">
    <meta property="og:image" content="https://mikestew5.github.io/bottom-shelf-golf/bsgheader.png">
    <meta property="og:url" content="https://mikestew5.github.io/bottom-shelf-golf/bottom_shelf_golf_iphone.html">
    <meta property="og:type" content="website">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>
    <script>
        firebase.initializeApp({
            apiKey: "AIzaSyBk6-GOW3oJ78G3TYCvi8D0R9Hl4UYQfSY",
            authDomain: "bottomshelfgames-d1ce6.firebaseapp.com",
            databaseURL: "https://bottomshelfgames-d1ce6-default-rtdb.firebaseio.com",
            projectId: "bottomshelfgames-d1ce6",
            storageBucket: "bottomshelfgames-d1ce6.firebasestorage.app",
            messagingSenderId: "774344837404",
            appId: "1:774344837404:web:e85d614e6ceb6a047712d9"
        });
        const db = firebase.database();
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&family=Cormorant+Garamond:wght@400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #006243;
            color: #fff;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* ==================== START SCREEN ==================== */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #006243;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 1000;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        #startScreen.hidden {
            display: none;
        }

        .start-title {
            font-family: 'Playfair Display', serif;
            font-size: 28px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            margin-bottom: 6px;
            text-align: center;
        }

        .hole-select-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            max-width: 340px;
            padding: 0 12px 60px;
            justify-items: center;
        }

        .hole-button {
            background: rgba(20, 20, 20, 0.8);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 100%;
        }

        .hole-button:hover {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            border-color: #ff6600;
        }

        .hole-preview {
            width: 130px;
            height: 160px;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 6px;
            overflow: hidden;
        }

        .hole-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .hole-name {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 14px;
            color: #FFD700;
        }

        .hole-par {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 11px;
            color: #888;
        }

        /* ==================== MODE SELECT & NAME ENTRY ==================== */
        .mode-select {
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            margin-bottom: 0;
            justify-content: center;
        }

        .mode-btn {
            font-family: 'Playfair Display', serif;
            font-size: 22px;
            padding: 16px 40px;
            border: 2px solid #FFD700;
            border-radius: 10px;
            background: rgba(20, 20, 20, 0.8);
            color: #FFD700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn:hover {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        .mode-btn-play {
            background: #FFD700;
            color: #000;
        }

        .mode-btn-play:hover {
            background: #ff6600;
            color: #fff;
        }

        .name-entry {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .name-entry-label {
            font-family: 'Playfair Display', serif;
            font-size: 22px;
            color: #FFD700;
        }

        .name-input {
            font-family: 'Playfair Display', serif;
            font-size: 24px;
            text-align: center;
            width: 120px;
            padding: 8px;
            border: 2px solid #FFD700;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            text-transform: uppercase;
            outline: none;
        }

        .name-input::placeholder {
            color: #666;
        }

        /* ==================== LEADERBOARD ==================== */
        .leaderboard-section {
            margin-top: 10px;
            border-top: 1px solid #FFD700;
            padding-top: 8px;
            width: 100%;
        }

        .leaderboard-section h3 {
            font-family: 'Playfair Display', serif;
            font-size: 14px;
            color: #FFD700;
            margin-bottom: 6px;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Playfair Display', serif;
        }

        .leaderboard-table th {
            font-size: 10px;
            color: #888;
            padding: 2px 4px;
            border-bottom: 1px solid #555;
        }

        .leaderboard-table td {
            padding: 3px 4px;
            font-size: 11px;
            border-bottom: 1px solid #333;
            color: #ccc;
        }

        .leaderboard-table tr.current-entry td {
            color: #FFD700;
            font-weight: bold;
        }

        /* ==================== GAME SCREEN ==================== */
        #gameScreen {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 4px;
            overflow: hidden;
        }

        #gameScreen.hidden {
            display: none;
        }

        /* ==================== iPOD (compact horizontal) ==================== */
        #ipodOverlay {
            position: relative;
            z-index: 10;
            background: linear-gradient(145deg, #f5f5f5, #e0e0e0);
            border: 2px solid #999;
            border-radius: 10px;
            padding: 4px 8px;
            width: 345px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 2px;
        }

        #ipodScreen {
            background: linear-gradient(135deg, #b3d9ff, #99ccff);
            border: 1px solid #666;
            border-radius: 4px;
            padding: 3px 5px;
            height: 40px;
            flex: 1;
            font-size: 8px;
            color: #000;
            font-family: 'Cormorant Garamond', serif;
            overflow: hidden;
            cursor: pointer;
            animation: screenPulse 1.2s ease-in-out infinite;
        }

        @keyframes screenPulse {
            0%, 100% { box-shadow: 0 0 4px rgba(100,180,255,0.4); transform: scale(1); }
            50% { box-shadow: 0 0 18px rgba(100,180,255,1), 0 0 35px rgba(100,180,255,0.6), 0 0 50px rgba(100,180,255,0.3); transform: scale(1.03); }
        }

        .nowPlaying { font-weight: bold; font-size: 7px; letter-spacing: 0.5px; }
        .songTitle { font-size: 9px; margin: 1px 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        #clickWheel {
            position: relative;
            width: 44px;
            height: 44px;
            background: linear-gradient(145deg, #ddd, #ccc);
            border-radius: 50%;
            border: 2px solid #999;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        #centerButton {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 20px; height: 20px;
            background: linear-gradient(145deg, #ccc, #bbb);
            border-radius: 50%;
            border: 1px solid #999;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            transition: all 0.1s;
        }

        #centerButton:hover {
            background: linear-gradient(145deg, #bbb, #aaa);
            transform: translate(-50%, -50%) scale(0.95);
        }

        .wheelButton {
            position: absolute;
            width: 12px; height: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 10px;
            color: #666;
            transition: all 0.1s;
        }

        #prevBtn { top: 3px; left: 50%; transform: translateX(-50%); }
        #nextBtn { bottom: 3px; left: 50%; transform: translateX(-50%); }
        #playBtn { right: 3px; top: 50%; transform: translateY(-50%); }
        #pauseBtn { left: 3px; top: 50%; transform: translateY(-50%); font-size: 8px; }

        #ipodPowerBtn {
            width: 28px; height: 28px;
            background: #cc0000;
            border: 2px solid #990000;
            border-radius: 50%;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; color: #fff;
            animation: powerPulse 2s ease-in-out infinite;
            transition: background 0.2s, border-color 0.2s;
            flex-shrink: 0;
        }

        @keyframes powerPulse {
            0%, 100% { box-shadow: 0 0 3px rgba(255,0,0,0.3); }
            50% { box-shadow: 0 0 8px rgba(255,0,0,0.8), 0 0 14px rgba(255,0,0,0.3); }
        }

        #ipodPowerBtn.off {
            background: #555;
            border-color: #333;
            color: #999;
            animation: none;
            box-shadow: none;
        }


        /* ==================== GOLF COURSE ==================== */
        .course-container {
            position: relative;
            background: #2d1810;
            padding: 4px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.9);
        }

        #golfCanvas {
            display: block;
            width: 345px;
            height: 460px;
            border: 2px solid #0d0805;
            border-radius: 3px;
            cursor: crosshair;
            touch-action: none;
        }

        /* ==================== OVERLAY BUTTONS (bottom bar) ==================== */
        .game-bottom-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 345px;
            padding: 3px 0;
            gap: 4px;
        }

        .overlay-btn {
            position: relative;
            background: #8b1a1a;
            border: 2px solid #a52a2a;
            border-radius: 6px;
            padding: 4px 8px;
            cursor: pointer;
            z-index: 5;
            transition: transform 0.15s, background 0.15s;
            text-align: center;
            box-shadow: 2px 3px 0px rgba(0,0,0,0.4);
            flex: 1;
        }

        .overlay-btn:hover {
            background: #a02020;
        }

        .overlay-btn:active {
            transform: scale(0.97);
            box-shadow: 1px 1px 0px rgba(0,0,0,0.4);
        }

        .overlay-btn-icon {
            font-size: 36px;
            line-height: 1;
        }

        .overlay-btn-icon img {
            display: block;
            margin: 0 auto;
        }

        .overlay-btn-label {
            font-size: 9px;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Playfair Display', serif;
            margin-top: 1px;
        }

        /* ==================== SCORE INFO (horizontal bar above canvas) ==================== */
        .score-info {
            position: relative;
            width: 345px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin-bottom: 2px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #FFD700;
            border-radius: 6px;
            z-index: 10;
            gap: 1px 6px;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0;
            font-size: 14px;
            gap: 3px;
            transform: scaleY(1.4);
            transform-origin: center;
            line-height: 1;
        }

        .score-label {
            color: #888;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .score-value {
            color: #FFD700;
            font-weight: 900;
        }

        /* ==================== COMPLETION MESSAGE ==================== */
        .completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px 24px;
            border-radius: 14px;
            border: 3px solid #FFD700;
            text-align: center;
            z-index: 100;
            display: none;
            font-family: 'Playfair Display', serif;
            max-width: 320px;
            width: 90%;
        }

        .completion-message.show {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .completion-title {
            font-size: 28px;
            color: #FFD700;
            margin-bottom: 10px;
        }

        .completion-strokes {
            font-size: 22px;
            color: #fff;
            margin-bottom: 16px;
        }

        .completion-score-to-par {
            font-size: 16px;
            color: #8f8;
            margin-bottom: 12px;
        }

        .completion-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .completion-btn {
            background: #FFD700;
            color: #000;
            border: none;
            padding: 10px 24px;
            font-size: 14px;
            font-family: 'Playfair Display', serif;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .completion-btn-secondary {
            background: #666;
            color: #fff;
        }

        .completion-btn:hover {
            background: #ff6600;
        }

        .completion-btn-secondary:hover {
            background: #888;
        }

        /* ==================== POWERUP FEEDBACK ==================== */
        .powerup-feedback {
            position: absolute;
            font-size: 24px;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            pointer-events: none;
            animation: fadeOut 1s forwards;
            z-index: 50;
        }

        .powerup-feedback.mp-reaction {
            font-size: 13px;
            color: #fff;
            background: rgba(0,0,0,0.55);
            padding: 3px 8px;
            border-radius: 6px;
            animation: reactionFade 4s forwards;
            white-space: nowrap;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-40px); }
        }

        @keyframes reactionFade {
            0% { opacity: 1; transform: translateY(0); }
            75% { opacity: 1; transform: translateY(-8px); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* ==================== MULTIPLAYER ==================== */
        .mp-lobby-player {
            display: flex; align-items: center; gap: 6px;
            padding: 5px 8px; margin: 3px 0;
            background: rgba(0,0,0,0.3); border-radius: 6px;
            font-family: 'Playfair Display', serif; font-style: italic;
            font-size: 14px; color: #fff;
        }
        .mp-slot-dot {
            width: 10px; height: 10px; border-radius: 50%;
            display: inline-block; flex-shrink: 0;
        }
        .mp-lobby-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 6px 10px; margin: 4px 0;
            background: rgba(0,0,0,0.4); border-radius: 6px;
            border: 1px solid #555; font-family: 'Playfair Display', serif;
            font-style: italic; color: #fff; font-size: 13px;
        }
        .mp-lobby-item.full { opacity: 0.5; }
        .mp-player-chip {
            display: inline-block; padding: 2px 6px;
            border-radius: 8px; font-family: 'Cormorant Garamond', serif;
            font-size: 10px; background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,215,0,0.3); color: #fff;
            pointer-events: none;
        }
        .mp-player-chip.active { outline: 2px solid #FFD700; }
        .mp-player-chip.holed-out { opacity: 0.5; text-decoration: line-through; }
        .mp-reaction-btn { pointer-events: auto; }
        .mp-scorecard {
            border-collapse: collapse; width: 100%; font-family: 'Playfair Display', serif;
            font-style: italic; font-size: 11px;
        }
        .mp-scorecard th, .mp-scorecard td {
            padding: 3px 4px; text-align: center; border-bottom: 1px solid rgba(255,215,0,0.2);
        }
        .mp-scorecard th { color: #888; font-size: 9px; }
        .mp-scorecard .par-row td { color: #aaa; font-size: 9px; }
        .mp-scorecard .player-row td { color: #fff; }
        .mp-scorecard .under-par { color: #44ff44; }
        .mp-scorecard .over-par { color: #ff4444; }
        .mp-scorecard .even-par { color: #fff; }

        /* ==================== DJ STAND OVERLAY ==================== */
        #djOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }
        #djOverlay.show { display: flex; }

        #djCloseBtn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #fff;
            font-size: 48px;
            font-weight: 900;
            cursor: pointer;
            z-index: 510;
            line-height: 1;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
        }

        .dj-frame-wrapper {
            width: 100vw;
            height: 95vh;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            border-radius: 4px;
        }

        #djStandFrame {
            width: 100%;
            height: 100%;
            border: none;
        }
    </style>
</head>
<body>
    <!-- START SCREEN -->
    <div id="startScreen">
        <div class="start-title">
            <!--üèåÔ∏è WOBBLY PUTT-PUTT üèåÔ∏è-->
        </div>
        <img src="bsgheader.png" alt="Bottom Shelf Golf" style="max-width: 300px; width: 80vw; object-fit: contain;">

        <!-- Mode Selection -->
        <div id="modeSelect" class="mode-select">
            <button class="mode-btn" id="practiceBtn">PRACTICE</button>
            <button class="mode-btn mode-btn-play" id="playBtn2">PLAY</button>
        </div>

        <!-- Play Sub-Mode Selection -->
        <div id="playModeSelect" style="display:none; text-align:center;">
            <div style="font-family: 'Playfair Display', serif; font-style: italic; font-size: 22px; color: #FFD700; margin-bottom: 16px;">
                SELECT MODE
            </div>
            <div class="mode-select">
                <button class="mode-btn mode-btn-play" id="soloPlayBtn">SOLO CHALLENGE</button>
                <button class="mode-btn" id="multiplayerBtn">MULTIPLAYER</button>
            </div>
            <button class="mode-btn" id="playModeBackBtn" style="font-size: 16px; padding: 10px 24px; margin-top: 12px;">BACK</button>
        </div>

        <!-- Player Name Entry (main menu, optional) -->
        <div id="mainNameEntry" style="text-align: center;">
            <div style="font-family: 'Playfair Display', serif; font-style: italic; font-size: 18px; color: #FFD700; margin-bottom: 10px;">
                ENTER NAME (OPTIONAL)
            </div>
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <input type="text" id="mainNameInput" class="name-input" maxlength="4" placeholder="NAME"
                    autocomplete="off" style="width: 140px; font-size: 24px; padding: 10px;">
                <button class="mode-btn" id="mainNameSubmit" style="font-size: 18px; padding: 10px 20px;">OK</button>
            </div>
        </div>

        <!-- Player Info + Pro Shop (shown after name entered) -->
        <div id="playerInfo" style="display: none; text-align: center;">
            <div id="playerWelcome" style="font-family: 'Playfair Display', serif; font-style: italic; font-size: 20px; color: #FFD700;"></div>
            <div id="coinDisplay" style="font-family: 'Cormorant Garamond', serif; font-size: 16px; color: #FFD700; margin: 6px 0;"></div>
            <button class="mode-btn mode-btn-play" id="proShopBtn" style="font-size: 18px; padding: 12px 28px;">PRO SHOP</button>
        </div>

        <!-- Name Entry (play mode) -->
        <div id="nameEntry" class="name-entry" style="display:none;">
            <div class="name-entry-label">ENTER YOUR NAME</div>
            <input type="text" id="playerNameInput" class="name-input" maxlength="4" placeholder="NAME" autocomplete="off">
            <button class="mode-btn mode-btn-play" id="nameSubmitBtn">START</button>
        </div>

        <!-- Hole Selection (practice mode) -->
        <div class="hole-select-grid" id="holeGrid" style="display:none;">
            <!-- Holes will be populated by JavaScript -->
        </div>

        <!-- Pro Shop Screen -->
        <div id="proShopScreen" style="display: none;">
            <div style="font-family: 'Playfair Display', serif; font-style: italic; font-size: 22px; color: #FFD700; margin-bottom: 4px;">PRO SHOP</div>
            <div id="shopCoinDisplay" style="font-family: 'Playfair Display', serif; font-style: italic; font-size: 13px; color: #FFD700; margin-bottom: 10px;"></div>
            <div class="hole-select-grid" id="shopGrid"></div>
            <button class="mode-btn" id="shopBackBtn" style="margin-top: 16px; font-size: 18px; padding: 10px 28px;">BACK</button>
            <div style="height: 60px;"></div>
        </div>
    </div>

    <!-- MULTIPLAYER LOBBY SCREEN -->
    <div id="lobbyScreen" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:#006243; z-index:1000; align-items:center; justify-content:center; overflow-y:auto;">
        <div style="text-align:center; color:#fff; width:100%; max-width:340px; padding: 16px;">
            <h2 style="font-family:'Playfair Display',serif; font-style:italic; font-size:22px; color:#FFD700; margin-bottom:4px;">MULTIPLAYER</h2>
            <p style="font-family:'Cormorant Garamond',serif; font-size:13px; color:#ccc; margin-bottom:16px;">play with friends</p>

            <!-- Step 1: Name Entry (only if no playerName) -->
            <div id="mpNameEntry" style="display:none;">
                <p style="font-family:'Playfair Display',serif; font-style:italic; font-size:14px; color:#FFD700; margin-bottom:10px;">ENTER YOUR NAME</p>
                <input type="text" id="mpNameInput" class="name-input" maxlength="4" placeholder="NAME" autocomplete="off" style="width:120px; font-size:24px; padding:6px; margin-bottom:10px;">
                <br><button class="mode-btn mode-btn-play" id="mpNameConfirmBtn" style="font-size:16px; padding:8px 20px;">LET'S GO</button>
                <br><button class="mode-btn" id="mpNameBackBtn" style="font-size:14px; padding:6px 16px; margin-top:10px;">BACK</button>
            </div>

            <!-- Step 2: Browse Lobbies -->
            <div id="mpLobbyBrowser" style="display:none;">
                <div id="mpLobbyList" style="max-height:200px; overflow-y:auto; margin-bottom:10px;"></div>
                <p id="mpNoLobbiesMsg" style="font-family:'Patrick Hand',cursive; font-size:13px; color:#ccc; margin-top:10px;">No active courses. Create one!</p>
                <button class="mode-btn mode-btn-play" id="mpCreateLobbyBtn" style="font-size:16px; padding:8px 20px;">CREATE COURSE</button>
                <br><button class="mode-btn" id="mpBrowserBackBtn" style="font-size:14px; padding:6px 16px; margin-top:10px;">BACK</button>
            </div>

            <!-- Step 3: Create Lobby -->
            <div id="mpLobbyCreate" style="display:none;">
                <p style="font-family:'Playfair Display',serif; font-style:italic; font-size:14px; color:#FFD700; margin-bottom:10px;">COURSE NAME</p>
                <input type="text" id="mpLobbyNameInput" class="name-input" maxlength="20" placeholder="Name..." autocomplete="off" style="width:200px; font-size:18px; padding:6px; margin-bottom:10px;">
                <br><button class="mode-btn mode-btn-play" id="mpCreateConfirmBtn" style="font-size:16px; padding:8px 20px;">CREATE</button>
                <p id="mpCreateError" style="font-family:'Patrick Hand',cursive; font-size:14px; color:#ff4444; margin-top:10px; display:none;"></p>
                <br><button class="mode-btn" id="mpCreateBackBtn" style="font-size:14px; padding:6px 16px; margin-top:10px;">BACK</button>
            </div>

            <!-- Step 4: Lobby Room -->
            <div id="mpLobbyRoom" style="display:none;">
                <h3 id="mpLobbyRoomName" style="font-family:'Playfair Display',serif; font-style:italic; font-size:22px; color:#FFD700; margin-bottom:4px;"></h3>
                <div id="mpLobbyPlayerList" style="margin:10px 0;"></div>
                <p id="mpLobbyPlayerCount" style="font-family:'Patrick Hand',cursive; font-size:13px; color:#ccc; margin-top:8px;">1/4 players</p>
                <p id="mpWaitingMsg" style="font-family:'Playfair Display',serif; font-style:italic; font-size:15px; color:#FFD700; margin-top:10px;">Waiting for opponent...</p>
                <button class="mode-btn" id="mpLeaveLobbyBtn" style="font-size:14px; padding:6px 16px; margin-top:10px;">LEAVE</button>
            </div>
        </div>
    </div>

    <!-- Lobby Closed Screen -->
    <div id="mpLobbyClosed" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.9); z-index:1000; align-items:center; justify-content:center; flex-direction:column; text-align:center;">
        <div style="font-family:'Playfair Display',serif; font-style:italic; font-size:20px; color:#FFD700; margin-bottom:8px;">HOST DISCONNECTED</div>
        <p style="font-family:'Cormorant Garamond',serif; font-size:14px; color:#ccc; margin-bottom:16px;">The course has been closed.</p>
        <button class="mode-btn mode-btn-play" id="mpLobbyClosedBtn" style="font-size:14px; padding:8px 24px;">BACK TO MENU</button>
    </div>

    <!-- GAME SCREEN -->
    <div id="gameScreen" class="hidden">
        <!-- Score bar (above canvas) -->
        <div class="score-info">
            <div class="score-row">
                <span class="score-label">Hole:</span>
                <span class="score-value" id="holeNumber">1</span>
            </div>
            <div class="score-row">
                <span class="score-label">Strokes:</span>
                <span class="score-value" id="strokeCount">0</span>
            </div>
            <div class="score-row">
                <span class="score-label">Par:</span>
                <span class="score-value" id="parValue">1</span>
            </div>
            <div class="score-row">
                <span class="score-label">Total:</span>
                <span class="score-value" id="totalStrokesValue">0</span>
            </div>
            <div class="score-row">
                <span class="score-label">To Par:</span>
                <span class="score-value" id="scoreToParValue">E</span>
            </div>
            <button id="resetHoleBtn" style="
                padding: 3px 8px;
                background: rgba(255, 50, 50, 0.8);
                color: #fff;
                border: 1px solid #FFD700;
                border-radius: 4px;
                font-family: 'Playfair Display', serif;
                font-style: italic;
                font-size: 9px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 1px;
            ">Reset</button>
            <button id="leaveGameBtn" style="
                display: none;
                padding: 3px 8px;
                background: rgba(255, 50, 50, 0.8);
                color: #fff;
                border: 1px solid #FFD700;
                border-radius: 4px;
                font-family: 'Playfair Display', serif;
                font-style: italic;
                font-size: 9px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 1px;
            ">Leave</button>
            <button id="mainMenuBtn" style="
                padding: 3px 8px;
                background: rgba(139, 69, 19, 0.8);
                color: #FFD700;
                border: 1px solid #FFD700;
                border-radius: 4px;
                font-family: 'Playfair Display', serif;
                font-style: italic;
                font-size: 9px;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 1px;
            ">Menu</button>
        </div>

        <!-- Wind bar: coins (left) | wind flag (center) | wind buttons (right, practice only) -->
        <div id="windControls" style="
            display: none;
            width: 345px;
            padding: 2px 4px;
        ">
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <!-- BS Coins (left) -->
                <div id="coinBalanceRow" style="display:none; align-items: center; gap: 4px; flex: 1;">
                    <canvas id="coinIcon" width="18" height="18" style="width:18px;height:18px;"></canvas>
                    <span style="font-family:'Playfair Display',serif; font-style:italic; font-size:16px; color:#FFD700; font-weight:900;" id="coinBalanceValue">0</span>
                </div>
                <div id="coinSpacer" style="flex:1;"></div>

                <!-- Wind flag + label (center) -->
                <div style="display: flex; align-items: center; gap: 6px;">
                    <canvas id="windFlagCanvas" width="50" height="35" style="width:50px;height:35px;"></canvas>
                    <div id="windLabel" style="
                        font-family: 'Playfair Display', serif;
                        font-style: italic;
                        font-size: 16px;
                        font-weight: 900;
                        color: #fff;
                    ">0 mph</div>
                </div>

                <!-- Wind change buttons (right, practice only) -->
                <div id="windButtons" style="display: flex; gap: 2px; min-width: 60px; justify-content: flex-end;">
                    <button class="wind-btn" data-wind="-1" style="
                        padding: 2px 4px; font-size: 9px; cursor: pointer;
                        background: rgba(255,255,255,0.8); border: 1px solid #999; border-radius: 3px;
                        font-family: 'Cormorant Garamond', serif; color: #000;
                    ">-1</button>
                    <button class="wind-btn" data-wind="-0.5" style="
                        padding: 2px 4px; font-size: 9px; cursor: pointer;
                        background: rgba(255,255,255,0.8); border: 1px solid #999; border-radius: 3px;
                        font-family: 'Cormorant Garamond', serif; color: #000;
                    ">-.5</button>
                    <button class="wind-btn" data-wind="0" style="
                        padding: 2px 4px; font-size: 9px; cursor: pointer;
                        background: rgba(255,255,255,0.8); border: 1px solid #999; border-radius: 3px;
                        font-family: 'Cormorant Garamond', serif; color: #000;
                    ">0</button>
                    <button class="wind-btn" data-wind="0.5" style="
                        padding: 2px 4px; font-size: 9px; cursor: pointer;
                        background: rgba(255,255,255,0.8); border: 1px solid #999; border-radius: 3px;
                        font-family: 'Cormorant Garamond', serif; color: #000;
                    ">+.5</button>
                    <button class="wind-btn" data-wind="1" style="
                        padding: 2px 4px; font-size: 9px; cursor: pointer;
                        background: rgba(255,255,255,0.8); border: 1px solid #999; border-radius: 3px;
                        font-family: 'Cormorant Garamond', serif; color: #000;
                    ">+1</button>
                </div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="course-container">
            <canvas id="golfCanvas" width="600" height="800"></canvas>

            <!-- Multiplayer HUD -->
            <div id="mpHUD" style="display:none; position:absolute; top:0; left:0; right:0; z-index:30; pointer-events:none;">
                <div id="mpTurnIndicator" style="
                    text-align:center; padding:4px 8px; font-family:'Playfair Display',serif;
                    font-style:italic; font-size:12px; color:#FFD700; background:rgba(0,0,0,0.7);
                    border-bottom:2px solid #FFD700;
                "></div>
                <div id="mpPlayerChips" style="
                    display:flex; justify-content:center; gap:4px; flex-wrap:wrap;
                    padding:3px 6px;
                "></div>
            </div>

            <!-- Reaction buttons (shown when not your turn) -->
            <div id="mpReactionBar" style="display:none; position:absolute; bottom:10px; left:0; right:0; z-index:20; justify-content:center; gap:4px; flex-wrap:wrap; padding:0 6px;">
                <button class="mode-btn mp-reaction-btn" data-reaction="Nice Shot!" style="font-size:10px; padding:4px 8px;">Nice Shot!</button>
                <button class="mode-btn mp-reaction-btn" data-reaction="Oops!" style="font-size:10px; padding:4px 8px;">Oops!</button>
                <button class="mode-btn mp-reaction-btn" data-reaction="Wow!" style="font-size:10px; padding:4px 8px;">Wow!</button>
                <button class="mode-btn mp-reaction-btn" data-reaction="I'm having fun" style="font-size:10px; padding:4px 8px;">Fun!</button>
            </div>

            <!-- Multiplayer Hole Scorecard -->
            <div id="mpScorecardOverlay" class="completion-message" style="display:none;">
                <div id="mpScorecardTitle" class="completion-title" style="font-size:24px; margin-bottom:8px;">HOLE COMPLETE</div>
                <div id="mpScorecardBody" style="overflow-x:auto; margin-bottom:12px; font-size:11px;"></div>
                <div class="completion-buttons">
                    <button class="completion-btn" id="mpNextHoleBtn">NEXT HOLE</button>
                    <button class="completion-btn completion-btn-secondary" id="mpReturnMenuBtn">RETURN TO MENU</button>
                </div>
            </div>

            <!-- Completion Message -->
            <div class="completion-message" id="completionMessage">
                <div class="completion-title" id="completionTitle">HOLE IN ONE!</div>
                <div class="completion-strokes" id="completionStrokes">1 stroke</div>
                <div class="completion-score-to-par" id="completionScoreToPar">Score to Par: E</div>
                <div id="completionSummary" style="display:none; font-family: sans-serif; font-size: 14px; color: #ccc; margin-bottom: 10px; text-align: left; padding: 6px 10px; background: rgba(255,255,255,0.08); border-radius: 6px;"></div>
                <div id="completionCoins" style="display:none; font-family: 'Playfair Display', serif; font-style: italic; font-size: 18px; color: #FFD700; margin-bottom: 12px;">
                    <canvas id="completionCoinIcon" width="20" height="20" style="width:20px;height:20px;vertical-align:middle;margin-right:4px;"></canvas>
                    <span id="completionCoinsText"></span>
                </div>
                <div class="leaderboard-section" id="leaderboardSection" style="display:none;">
                    <h3>LEADERBOARD</h3>
                    <table class="leaderboard-table">
                        <thead>
                            <tr><th>#</th><th>NAME</th><th>TO PAR</th></tr>
                        </thead>
                        <tbody id="leaderboardBody"></tbody>
                    </table>
                </div>
                <div class="completion-buttons">
                    <button class="completion-btn" id="replayHoleBtn" style="display:none;">REPLAY HOLE</button>
                    <button class="completion-btn" id="nextHoleBtn">NEXT HOLE</button>
                    <button class="completion-btn completion-btn-secondary" id="returnMenuBtn">RETURN TO MENU</button>
                </div>
            </div>
        </div>

        <!-- Bottom bar (wing, club, beer) -->
        <div class="game-bottom-bar">
            <div class="overlay-btn" id="wingBtn">
                <div class="overlay-btn-icon"><img src="marlboro.png" style="width:50px;height:50px;object-fit:contain;"></div>
            </div>
            <div class="overlay-btn" id="clubBtn" style="background:#c8a200; border-color:#9a7d00;">
                <div class="overlay-btn-icon" style="font-size:36px;">üèåÔ∏è</div>
                <div class="overlay-btn-label" style="color:#000;">DRIVER</div>
            </div>
            <div class="overlay-btn" id="beerBtn">
                <div class="overlay-btn-icon"><img src="budweiser.png" style="width:50px;height:50px;object-fit:contain;"></div>
            </div>
        </div>

        <!-- iPod (compact horizontal) -->
        <div id="ipodOverlay">
            <div id="ipodScreen">
                <div class="nowPlaying">‚ô´ NOW PLAYING</div>
                <div class="songTitle" id="songDisplay">Press Play</div>
            </div>
            <div style="display:flex; flex-direction:column; align-items:center; gap:2px;">
                <div id="ipodPowerBtn" class="off" title="Toggle Game/Free Mix Mode">‚èª</div>
            </div>
            <div id="clickWheel">
                <div id="centerButton" title="Play/Pause">‚ñ∂</div>
                <div class="wheelButton" id="prevBtn" title="Previous">‚óÄ</div>
                <div class="wheelButton" id="nextBtn" title="Next">‚ñ∂</div>
                <div class="wheelButton" id="playBtn" title="Play">‚ñ∂</div>
                <div class="wheelButton" id="pauseBtn" title="Pause">‚ùö‚ùö</div>
            </div>
        </div>
    </div>

    <!-- DJ Stand Overlay -->
    <div id="djOverlay">
        <button id="djCloseBtn">X</button>
        <div class="dj-frame-wrapper">
            <iframe id="djStandFrame" src="dj-stand-iphone.html" allow="autoplay; fullscreen"></iframe>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 800;
        const BALL_RADIUS = 10;
        const FRICTION = 0.985;
        const STOP_THRESHOLD = 0.15;
        const MAX_POWER = 100;
        const PREVIEW_DISTANCE = 300; // Constant preview length
        const BEND_K = 4; // Controls how exponential the bend curve is
        const BEND_MAX_ANGLE = 90 * Math.PI / 180; // 90 degrees max bend
        const BALL_BASE_RADIUS = BALL_RADIUS * 0.5; // Start at 50% size

        // Course hole definitions
        // Image coordinates are in 256x256 source pixels, scaled to 600x800 canvas
        const IMG_W = 256, IMG_H = 256;
        function imgToCanvas(ix, iy) {
            return { x: Math.round(ix / IMG_W * CANVAS_WIDTH), y: Math.round(iy / IMG_H * CANVAS_HEIGHT) };
        }

        const holes = [
            { id: 1, name: 'HOLE 1', par: 4, image: '1sthole.png', ballStart: imgToCanvas(145, 229), holePos: imgToCanvas(153, 26) },
            { id: 2, name: 'HOLE 2', par: 4, image: '2ndhole.png', ballStart: imgToCanvas(95, 236), holePos: imgToCanvas(113, 33) },
            { id: 3, name: 'HOLE 3', par: 4, image: '3rdhole.png', ballStart: imgToCanvas(96, 241), holePos: imgToCanvas(109, 24) },
            { id: 4, name: 'HOLE 4', par: 4, image: '4thhole.png', ballStart: imgToCanvas(138, 215), holePos: imgToCanvas(162, 23) },
            { id: 18, name: 'HOLE 18', par: 4, image: '18thhole.png', ballStart: imgToCanvas(133, 219), holePos: imgToCanvas(146, 23) }
        ];

        // Music tracks (Bottom Shelf playlist)
        const songs = [
            { title: "Time", file: "timemix.m4a" },
            { title: "Memphis", file: "newmemphismix.m4a" },
            { title: "Yellow Pine", file: "YELLOPINEMIX.m4a" },
            { title: "Man In Me", file: "maninme817master2.m4a" },
            { title: "Rainbow Spotted", file: "rainbowspottedskindregularmaster.m4a" },
            { title: "LWYD", file: "lwydmasterearlynov.m4a" },
            { title: "Mormon Wedding", file: "mymormonweddingmasterearlynov.m4a" },
            { title: "Hurt My Shoulder", file: "hurtmyshouldermasterearlynov.m4a" },
            { title: "Jumbotron", file: "jumbotronmasterearlynov.m4a" },
            { title: "Something Ain't Right", file: "somethingaintrightmaster1114.m4a" },
            { title: "I Bought A Bronco", file: "iboughtabroncomaster1114.m4a" },
            { title: "Slow Low", file: "jtronslowlowmaster.m4a" },
            { title: "Seeeekret", file: "jtronsseeeeeekretmaster.m4a" },
            { title: "Carolina Curveball", file: "carolinacurveballroughmaster.m4a" },
            { title: "Sure Is Cold", file: "sureiscoldroughmaster.m4a" },
            { title: "U Don't & Wedding", file: "udont&weddingroughmaster.m4a" },
            { title: "Divorce", file: "divorcedroughymaster.m4a" }
        ];

        // ==================== GAME STATE ====================
        const canvas = document.getElementById('golfCanvas');
        const ctx = canvas.getContext('2d');

        let currentHole = null;
        let currentHoleIndex = 0;
        let courseImage = null;
        let courseImageData = null; // For boundary detection

        let ball = {
            x: 300,
            y: 700,
            vx: 0,
            vy: 0,
            radius: BALL_RADIUS,
            displayRadius: BALL_BASE_RADIUS
        };

        let bendMeter = 0; // -5 to 5, starts at 0 (straight)
        let selectedClub = 'driver'; // driver, iron, putter
        const CLUB_DISTANCE_FRACTION = { driver: 0.9375, iron: 0.45, putter: 0.15 }; // driver = 0.75 * 1.25
        let strokes = 0;
        let totalStrokes = 0; // Cumulative strokes across all holes
        let totalPar = 0; // Cumulative par across all holes played
        let holeStartDistance = 0; // Distance from tee to hole, set once per hole
        let isTeeShotActive = true; // True until first shot is taken
        let holeRadius = 19; // 3/4 of original 25

        // Bend shot tracking
        let shotCumulativeDistance = 0;
        let shotExpectedDistance = 0;
        let shotTotalBendAngle = 0;
        let shotBendActive = false;
        let shotPrevT = 0; // Track previous t for incremental angle

        // Shot summary & stats
        let shotSummaryMessages = [];
        let shotBeersUsed = 0;
        let shotCigsUsed = 0;
        let displayBeers = 0;
        let displayCigs = 0;

        // Hole-level accumulators for completion screen
        let holeSummaryMessages = [];
        let holeBeersTotal = 0;
        let holeCigsTotal = 0;
        let frozenStatSpeed = 0;      // mph
        let frozenStatDistance = 0;    // feet (updated live)
        let frozenStatAirTime = 0;    // seconds
        let frozenStatSwag = 0;       // percentage 0-100
        let frozenStatClub = '';
        let shotStatsVisible = false;

        // Realistic stat constants
        const CLUB_AIR_TIME = { driver: 6.0, iron: 4.5, putter: 0 };
        const MPH_PER_PX_FRAME = 30.22;  // 170 mph / 5.625 px/frame (full power driver)
        const PAR4_HOLE_FT = 650;          // Tuned tee-to-hole distance for realistic shot stats

        // Beer/cig images for summary box
        const beerImg = new Image(); beerImg.src = 'budweiser.png';
        const cigImg = new Image(); cigImg.src = 'marlboro.png';

        // Multiplayer chat box
        let mpChatMessages = []; // { text, time }

        // Post-shot spin state
        let isSpinDragging = false;
        let spinDragStartX = 0;

        // Wind system (practice mode only)
        let windStrength = 0;    // 0 to 1 (0% to 100%)
        let windDirection = 1;   // +1 or -1 (right or left)
        let clouds = [];         // Array of {x, y, width, height, speed, opacity}

        // Tree bounce state (separate flags for ascending/descending ball size)
        let treeBounceAscending = false;
        let treeBounceDescending = false;

        // Frozen predictor path and meters (cached when shot is taken)
        let frozenPredictorPoints = null;
        let frozenPower = null;
        let frozenSwag = null;

        let isDragging = false;
        let isDraggingMeter = false;
        let meterPower = 1.0; // 0 to 1, driver starts at 100%
        let dragStartX = 0;
        let dragStartY = 0;
        let dragEndX = 0;
        let dragEndY = 0;
        const SHOT_DRAG_THRESHOLD = 30; // Min drag distance to register a shot
        let peakDragDistance = 0; // Track max drag distance during a drag

        let gameStarted = false;
        let gameMode = 'practice'; // 'practice' or 'play'
        let playerName = '';
        let playerCoins = 0;
        let playerItems = {}; // { goldBall: true, ... }
        let activeBall = 'default'; // 'default', 'goldBall', 'diamondBall'
        let ballMoving = false;
        let ballTrail = []; // stores {x, y} positions while ball moves
        let foulHighlightTimer = 0; // frames remaining for foul pulse
        let fireworkParticles = []; // hole-in fireworks

        // ==================== MULTIPLAYER STATE ====================
        let isMultiplayer = false;
        let isMyTurn = false;
        let myPlayerId = null;
        let mySlot = null;
        let currentLobby = null;
        let currentLobbyId = null;
        let lobbyPlayers = {};
        let turnOrder = [];
        let currentTurnIndex = 0;
        let mpPhase = 'firstShots'; // 'firstShots' | 'furthestFirst'
        let mpFirstShotsDone = {};
        let mpPlayerStates = {};
        let allPlayerBalls = {};
        let mpCurrentHoleIndex = 0;
        let mpListeners = [];
        let lobbyRoomListeners = [];
        let mpScorecard = {}; // { p1: [3, 2, ...], p2: [4, 3, ...] }
        let waitingForPlayers = false;
        let replayingOpponentShot = false;
        let replayingSlot = null; // which slot's shot we're replaying
        let myBallSaved = null; // save my ball state while replaying opponent shot
        const SLOT_COLORS = { p1: '#e74c3c', p2: '#3498db', p3: '#2ecc71', p4: '#f39c12' };

        // Golfer character
        let golfer = {
            swingAngle: 0,        // current club angle (radians)
            swingTarget: 0,       // angle to swing toward
            isSwinging: false,
            swingPhase: 'idle',   // idle, backswing, downswing, followthrough, reset
            swingTimer: 0,
            facingAngle: 0,       // direction the golfer faces (toward shot)
            fixedX: 0,            // stored position when ball is hit
            fixedY: 0,
            isFixed: false        // true while ball is moving
        };

        // ==================== CAMERA / ZOOM ====================
        const CLUB_ZOOM = { driver: 1.0, iron: 1.6, putter: 2.5 };
        let cameraZoom = 1.0;
        let cameraTargetZoom = 1.0;
        let cameraX = CANVAS_WIDTH / 2;
        let cameraY = CANVAS_HEIGHT / 2;
        let cameraTargetX = CANVAS_WIDTH / 2;
        let cameraTargetY = CANVAS_HEIGHT / 2;
        const CAMERA_LERP = 0.08;

        // DJ Stand bridge
        const djFrame = document.getElementById('djStandFrame');
        let djOverlayOpen = false;
        let gameMusicMode = false; // true = game controls music, false = free mix (default: free mix ON)
        let currentSongName = 'Press Play';

        // Auto-play random song: browsers require a user gesture for audio,
        // so we start music on the first click/touch on the page
        let menuMusicStarted = false;
        function tryStartMenuMusic() {
            if (menuMusicStarted) return;
            menuMusicStarted = true;
            sendToDJ({ type: 'setGameMode', enabled: false, resetDefaults: true });
            sendToDJ({ type: 'playRandom' });
            document.removeEventListener('click', tryStartMenuMusic, true);
            document.removeEventListener('touchstart', tryStartMenuMusic, true);
        }
        document.addEventListener('click', tryStartMenuMusic, true);
        document.addEventListener('touchstart', tryStartMenuMusic, true);

        // ==================== INITIALIZATION ====================
        function init() {
            loadHoleSelection();
            setupEventListeners();
            setupModeSelection();
        }

        // ==================== BOTTOM SHELF BANK ====================
        const bankRef = db.ref('bottom_shelf_bank');

        function loadPlayerData(name) {
            bankRef.child(name).once('value', (snapshot) => {
                const data = snapshot.val() || {};
                playerCoins = data.coins || 0;
                playerItems = data.items || {};
                activeBall = data.activeBall || 'default';
                updatePlayerUI();
            });
        }

        function savePlayerData() {
            if (!playerName) return;
            bankRef.child(playerName).set({
                coins: playerCoins,
                items: playerItems,
                activeBall: activeBall
            });
        }

        function drawCoinIcon(canvas) {
            const c = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w / 2, cy = h / 2, r = Math.min(w, h) / 2 - 1;
            c.clearRect(0, 0, w, h);
            // Gold circle
            const grd = c.createRadialGradient(cx - r * 0.25, cy - r * 0.25, r * 0.1, cx, cy, r);
            grd.addColorStop(0, '#FFF6A0');
            grd.addColorStop(0.4, '#FFD700');
            grd.addColorStop(1, '#B8860B');
            c.fillStyle = grd;
            c.beginPath();
            c.arc(cx, cy, r, 0, Math.PI * 2);
            c.fill();
            // Dark border
            c.strokeStyle = '#8B6914';
            c.lineWidth = 1;
            c.beginPath();
            c.arc(cx, cy, r, 0, Math.PI * 2);
            c.stroke();
            // "BS" text
            c.fillStyle = '#5C3D00';
            c.font = `bold ${r * 0.9}px Arial`;
            c.textAlign = 'center';
            c.textBaseline = 'middle';
            c.fillText('BS', cx, cy + 1);
            // Shine
            c.fillStyle = 'rgba(255,255,255,0.35)';
            c.beginPath();
            c.ellipse(cx - r * 0.2, cy - r * 0.3, r * 0.4, r * 0.2, -0.4, 0, Math.PI * 2);
            c.fill();
        }

        function updatePlayerUI() {
            document.getElementById('playerWelcome').textContent = `Welcome, ${playerName}`;
            document.getElementById('coinDisplay').textContent = `${playerCoins} Bottom Shelf Coins`;
            const shopCoins = document.getElementById('shopCoinDisplay');
            if (shopCoins) shopCoins.textContent = `${playerCoins} Bottom Shelf Coins`;
            // Update scoreboard coin balance
            const coinBalVal = document.getElementById('coinBalanceValue');
            if (coinBalVal) coinBalVal.textContent = playerCoins;
        }

        // ==================== PRO SHOP ====================
        const shopItems = [
            {
                id: 'eightBall',
                name: '8-Ball',
                cost: 8,
                description: 'The classic pool 8-ball'
            },
            {
                id: 'camoBall',
                name: 'Camo Ball',
                cost: 25,
                description: 'A rugged camouflage golf ball'
            },
            {
                id: 'goldBall',
                name: 'Gold Ball',
                cost: 50,
                description: 'A shiny gold golf ball'
            },
            {
                id: 'diamondBall',
                name: 'Diamond Ball',
                cost: 100,
                description: 'A dazzling diamond golf ball'
            }
        ];

        function drawBallPreview(pCtx, id) {
            if (id === 'goldBall') {
                const grd = pCtx.createRadialGradient(60, 58, 5, 70, 70, 30);
                grd.addColorStop(0, '#FFF6A0');
                grd.addColorStop(0.4, '#FFD700');
                grd.addColorStop(1, '#B8860B');
                pCtx.fillStyle = grd;
                pCtx.shadowColor = 'rgba(255,215,0,0.4)';
                pCtx.shadowBlur = 15;
                pCtx.beginPath();
                pCtx.arc(70, 70, 30, 0, Math.PI * 2);
                pCtx.fill();
                pCtx.shadowBlur = 0;
                pCtx.fillStyle = 'rgba(255,255,255,0.6)';
                pCtx.beginPath();
                pCtx.ellipse(60, 58, 10, 6, -0.5, 0, Math.PI * 2);
                pCtx.fill();
            } else if (id === 'diamondBall') {
                const grd = pCtx.createRadialGradient(58, 56, 3, 70, 70, 30);
                grd.addColorStop(0, '#FFFFFF');
                grd.addColorStop(0.3, '#E0F0FF');
                grd.addColorStop(0.6, '#A0D8FF');
                grd.addColorStop(1, '#6BB8E8');
                pCtx.fillStyle = grd;
                pCtx.shadowColor = 'rgba(160,216,255,0.6)';
                pCtx.shadowBlur = 20;
                pCtx.beginPath();
                pCtx.arc(70, 70, 30, 0, Math.PI * 2);
                pCtx.fill();
                pCtx.shadowBlur = 0;
                pCtx.fillStyle = 'rgba(255,255,255,0.8)';
                pCtx.beginPath();
                pCtx.ellipse(58, 56, 12, 7, -0.5, 0, Math.PI * 2);
                pCtx.fill();
                pCtx.fillStyle = 'rgba(255,255,255,0.5)';
                pCtx.beginPath();
                pCtx.ellipse(80, 62, 5, 3, 0.3, 0, Math.PI * 2);
                pCtx.fill();
            } else if (id === 'eightBall') {
                // Black ball base
                pCtx.fillStyle = '#111';
                pCtx.shadowColor = 'rgba(0,0,0,0.6)';
                pCtx.shadowBlur = 12;
                pCtx.beginPath();
                pCtx.arc(70, 70, 30, 0, Math.PI * 2);
                pCtx.fill();
                pCtx.shadowBlur = 0;
                // White circle for number
                pCtx.fillStyle = 'white';
                pCtx.beginPath();
                pCtx.arc(70, 68, 14, 0, Math.PI * 2);
                pCtx.fill();
                // Number 8
                pCtx.fillStyle = '#111';
                pCtx.font = 'bold 18px Arial';
                pCtx.textAlign = 'center';
                pCtx.textBaseline = 'middle';
                pCtx.fillText('8', 70, 69);
                // Shine
                pCtx.fillStyle = 'rgba(255,255,255,0.35)';
                pCtx.beginPath();
                pCtx.ellipse(60, 58, 10, 6, -0.5, 0, Math.PI * 2);
                pCtx.fill();
            } else if (id === 'camoBall') {
                // Base olive green
                pCtx.fillStyle = '#556B2F';
                pCtx.shadowColor = 'rgba(0,0,0,0.5)';
                pCtx.shadowBlur = 10;
                pCtx.beginPath();
                pCtx.arc(70, 70, 30, 0, Math.PI * 2);
                pCtx.fill();
                pCtx.shadowBlur = 0;
                // Camo splotches - clip to circle
                pCtx.save();
                pCtx.beginPath();
                pCtx.arc(70, 70, 30, 0, Math.PI * 2);
                pCtx.clip();
                // Dark green patches
                pCtx.fillStyle = '#2E4E1E';
                pCtx.beginPath(); pCtx.ellipse(58, 60, 14, 10, 0.4, 0, Math.PI * 2); pCtx.fill();
                pCtx.beginPath(); pCtx.ellipse(82, 78, 12, 8, -0.6, 0, Math.PI * 2); pCtx.fill();
                pCtx.beginPath(); pCtx.ellipse(70, 90, 10, 7, 0.2, 0, Math.PI * 2); pCtx.fill();
                // Tan/khaki patches
                pCtx.fillStyle = '#8B7D3C';
                pCtx.beginPath(); pCtx.ellipse(76, 60, 11, 8, -0.3, 0, Math.PI * 2); pCtx.fill();
                pCtx.beginPath(); pCtx.ellipse(56, 80, 10, 7, 0.5, 0, Math.PI * 2); pCtx.fill();
                // Dark brown patches
                pCtx.fillStyle = '#3B3518';
                pCtx.beginPath(); pCtx.ellipse(65, 72, 9, 6, 0.8, 0, Math.PI * 2); pCtx.fill();
                pCtx.beginPath(); pCtx.ellipse(80, 65, 8, 5, -0.4, 0, Math.PI * 2); pCtx.fill();
                pCtx.restore();
                // Shine
                pCtx.fillStyle = 'rgba(255,255,255,0.3)';
                pCtx.beginPath();
                pCtx.ellipse(60, 58, 10, 6, -0.5, 0, Math.PI * 2);
                pCtx.fill();
            } else {
                // Default white ball
                pCtx.fillStyle = 'white';
                pCtx.shadowColor = 'rgba(0,0,0,0.5)';
                pCtx.shadowBlur = 10;
                pCtx.beginPath();
                pCtx.arc(70, 70, 30, 0, Math.PI * 2);
                pCtx.fill();
                pCtx.shadowBlur = 0;
            }
        }

        function createShopCard(id, name, costText, costColor, actionLabel, actionStyle, onAction) {
            const card = document.createElement('div');
            card.className = 'hole-button';

            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = 140;
            previewCanvas.height = 140;
            previewCanvas.style.cssText = 'width:120px;height:120px;border-radius:6px;background:#2a2a2a;border:1px solid #555;';
            drawBallPreview(previewCanvas.getContext('2d'), id);
            card.appendChild(previewCanvas);

            const nameDiv = document.createElement('div');
            nameDiv.className = 'hole-name';
            nameDiv.textContent = name;
            card.appendChild(nameDiv);

            const costDiv = document.createElement('div');
            costDiv.className = 'hole-par';
            costDiv.textContent = costText;
            costDiv.style.color = costColor;
            card.appendChild(costDiv);

            if (actionLabel) {
                const btn = document.createElement('button');
                btn.className = 'mode-btn';
                btn.style.fontSize = '14px';
                btn.style.padding = '6px 20px';
                btn.style.marginTop = '6px';
                if (actionStyle === 'gold') {
                    btn.classList.add('mode-btn-play');
                } else if (actionStyle === 'equipped') {
                    btn.style.background = '#8f8';
                    btn.style.color = '#000';
                    btn.style.borderColor = '#8f8';
                    btn.style.cursor = 'default';
                }
                btn.textContent = actionLabel;
                if (onAction) {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        onAction();
                    });
                }
                card.appendChild(btn);
            }

            return card;
        }

        function loadProShop() {
            const grid = document.getElementById('shopGrid');
            grid.innerHTML = '';
            document.getElementById('shopCoinDisplay').textContent = `${playerCoins} Bottom Shelf Coins`;

            // Default ball card (always available)
            const isDefaultActive = activeBall === 'default';
            grid.appendChild(createShopCard(
                'default', 'Default Ball', 'Free', '#8f8',
                isDefaultActive ? 'EQUIPPED' : 'EQUIP',
                isDefaultActive ? 'equipped' : 'gold',
                isDefaultActive ? null : () => {
                    activeBall = 'default';
                    savePlayerData();
                    loadProShop();
                }
            ));

            // Shop items
            shopItems.forEach(item => {
                const owned = playerItems[item.id] === true;
                const canAfford = playerCoins >= item.cost;
                const isActive = activeBall === item.id;

                if (!owned) {
                    // Not owned ‚Äî show BUY or unaffordable
                    grid.appendChild(createShopCard(
                        item.id, item.name,
                        `${item.cost} coins`,
                        canAfford ? '#FFD700' : '#f88',
                        canAfford ? 'BUY' : null,
                        'gold',
                        canAfford ? () => {
                            playerCoins -= item.cost;
                            playerItems[item.id] = true;
                            activeBall = item.id;
                            savePlayerData();
                            loadProShop();
                            updatePlayerUI();
                        } : null
                    ));
                } else {
                    // Owned ‚Äî show EQUIP or EQUIPPED
                    grid.appendChild(createShopCard(
                        item.id, item.name,
                        'OWNED', '#8f8',
                        isActive ? 'EQUIPPED' : 'EQUIP',
                        isActive ? 'equipped' : 'gold',
                        isActive ? null : () => {
                            activeBall = item.id;
                            savePlayerData();
                            loadProShop();
                        }
                    ));
                }
            });
        }

        function setupModeSelection() {
            document.getElementById('practiceBtn').addEventListener('click', () => {
                gameMode = 'practice';
                document.getElementById('modeSelect').style.display = 'none';
                document.getElementById('mainNameEntry').style.display = 'none';
                document.getElementById('playerInfo').style.display = 'none';
                document.getElementById('nameEntry').style.display = 'none';
                document.getElementById('proShopScreen').style.display = 'none';
                document.getElementById('holeGrid').style.display = 'grid';
            });

            document.getElementById('playBtn2').addEventListener('click', () => {
                document.getElementById('modeSelect').style.display = 'none';
                document.getElementById('mainNameEntry').style.display = 'none';
                document.getElementById('playerInfo').style.display = 'none';
                document.getElementById('proShopScreen').style.display = 'none';
                document.getElementById('playModeSelect').style.display = 'block';
            });

            document.getElementById('soloPlayBtn').addEventListener('click', () => {
                gameMode = 'play';
                document.getElementById('playModeSelect').style.display = 'none';
                if (playerName) {
                    startHole(0);
                } else {
                    document.getElementById('nameEntry').style.display = 'flex';
                    document.getElementById('playerNameInput').focus();
                }
            });

            document.getElementById('playModeBackBtn').addEventListener('click', () => {
                document.getElementById('playModeSelect').style.display = 'none';
                document.getElementById('modeSelect').style.display = 'flex';
                if (playerName) {
                    document.getElementById('mainNameEntry').style.display = 'none';
                    document.getElementById('playerInfo').style.display = 'block';
                } else {
                    document.getElementById('mainNameEntry').style.display = 'block';
                }
            });

            document.getElementById('multiplayerBtn').addEventListener('click', () => {
                document.getElementById('playModeSelect').style.display = 'none';
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('lobbyScreen').style.display = 'flex';
                if (playerName) {
                    showMpLobbySection('mpLobbyBrowser');
                    showMpLobbyBrowser();
                } else {
                    showMpLobbySection('mpNameEntry');
                    document.getElementById('mpNameInput').focus();
                }
            });

            document.getElementById('nameSubmitBtn').addEventListener('click', startPlayMode);
            document.getElementById('playerNameInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') startPlayMode();
            });

            // Main menu name entry
            document.getElementById('mainNameSubmit').addEventListener('click', submitMainName);
            document.getElementById('mainNameInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') submitMainName();
            });

            // Pro shop buttons
            document.getElementById('proShopBtn').addEventListener('click', () => {
                document.getElementById('modeSelect').style.display = 'none';
                document.getElementById('playerInfo').style.display = 'none';
                document.getElementById('mainNameEntry').style.display = 'none';
                document.getElementById('proShopScreen').style.display = 'block';
                loadProShop();
            });

            document.getElementById('shopBackBtn').addEventListener('click', () => {
                document.getElementById('proShopScreen').style.display = 'none';
                document.getElementById('modeSelect').style.display = 'flex';
                if (playerName) {
                    document.getElementById('mainNameEntry').style.display = 'none';
                    document.getElementById('playerInfo').style.display = 'block';
                    updatePlayerUI();
                } else {
                    document.getElementById('mainNameEntry').style.display = 'block';
                    document.getElementById('playerInfo').style.display = 'none';
                }
            });
        }

        function submitMainName() {
            const input = document.getElementById('mainNameInput');
            const name = input.value.trim().toUpperCase();
            if (name.length === 0) return;
            playerName = name;
            document.getElementById('mainNameEntry').style.display = 'none';
            document.getElementById('playerInfo').style.display = 'block';
            loadPlayerData(name);
        }

        function startPlayMode() {
            const input = document.getElementById('playerNameInput');
            const name = input.value.trim().toUpperCase();
            if (name.length === 0) return;
            playerName = name;
            loadPlayerData(name);
            startHole(0); // Start at hole 1
        }

        function loadHoleSelection() {
            const grid = document.getElementById('holeGrid');
            grid.innerHTML = '';

            holes.forEach((hole, index) => {
                const btn = document.createElement('div');
                btn.className = 'hole-button';
                btn.innerHTML = `
                    <div class="hole-preview">
                        <img src="${hole.image}" alt="${hole.name}" onerror="this.style.display='none'">
                    </div>
                    <div class="hole-name">${hole.name}</div>
                    <div class="hole-par">Par ${hole.par}</div>
                `;
                btn.addEventListener('click', () => startHole(index));
                grid.appendChild(btn);
            });
        }

        // Find the white putting green area in the top half of the image
        function findPuttingGreen(imageData) {
            // Collect white/very light pixels in the top half of the course
            const whitePixels = [];
            for (let y = 0; y < CANVAS_HEIGHT * 0.5; y++) {
                for (let x = 0; x < CANVAS_WIDTH; x++) {
                    const i = (y * CANVAS_WIDTH + x) * 4;
                    const r = imageData.data[i];
                    const g = imageData.data[i + 1];
                    const b = imageData.data[i + 2];
                    const avg = (r + g + b) / 3;
                    const maxCh = Math.max(r, g, b);
                    const minCh = Math.min(r, g, b);
                    // White area: high brightness, low saturation
                    // Exclude the background grey (which is the area outside the course)
                    if (avg > 200 && avg < 252 && (maxCh - minCh) < 40) {
                        whitePixels.push({ x, y });
                    }
                }
            }

            if (whitePixels.length === 0) return null;

            // Find the densest cluster of white pixels (the putting green)
            const clusterRadius = 30;
            let bestX = 0, bestY = 0, bestCount = 0;

            const step = Math.max(1, Math.floor(whitePixels.length / 200));
            for (let i = 0; i < whitePixels.length; i += step) {
                const px = whitePixels[i];
                let nearby = 0;
                for (let j = 0; j < whitePixels.length; j++) {
                    const dx = px.x - whitePixels[j].x;
                    const dy = px.y - whitePixels[j].y;
                    if (dx * dx + dy * dy < clusterRadius * clusterRadius) {
                        nearby++;
                    }
                }
                if (nearby > bestCount) {
                    bestCount = nearby;
                    bestX = px.x;
                    bestY = px.y;
                }
            }

            // Get centroid of the best cluster
            let totalX = 0, totalY = 0, count = 0;
            for (const px of whitePixels) {
                const dx = px.x - bestX;
                const dy = px.y - bestY;
                if (dx * dx + dy * dy < clusterRadius * clusterRadius) {
                    totalX += px.x;
                    totalY += px.y;
                    count++;
                }
            }

            console.log('Putting green white pixels:', whitePixels.length, 'Cluster size:', count);
            return { x: Math.round(totalX / count), y: Math.round(totalY / count) };
        }

        // Find the figure's golf club tip to place the ball
        function findTeeBox(imageData) {
            // Step 1: Find bright blue/purple pixels (the figure's body)
            const figurePixels = [];
            for (let y = 0; y < CANVAS_HEIGHT; y++) {
                for (let x = 0; x < CANVAS_WIDTH; x++) {
                    const i = (y * CANVAS_WIDTH + x) * 4;
                    const r = imageData.data[i];
                    const g = imageData.data[i + 1];
                    const b = imageData.data[i + 2];
                    // Bright blue/purple: high blue, blue > green, blue > red-30
                    if (b > 140 && b > g + 30 && b > r - 30 && (r + g + b) > 200) {
                        figurePixels.push({ x, y });
                    }
                }
            }

            if (figurePixels.length === 0) {
                console.log('No figure found');
                return null;
            }

            // Get centroid of figure
            let fx = 0, fy = 0;
            for (const px of figurePixels) {
                fx += px.x;
                fy += px.y;
            }
            fx = fx / figurePixels.length;
            fy = fy / figurePixels.length;
            console.log('Figure found at:', Math.round(fx), Math.round(fy), 'Pixels:', figurePixels.length);

            // Step 2: Find grey pixels near the figure (the golf club/stick)
            // Search in a radius around the figure for grey (low saturation, medium brightness)
            const searchRadius = 60;
            const greyPixels = [];
            const minX = Math.max(0, Math.round(fx) - searchRadius);
            const maxX = Math.min(CANVAS_WIDTH - 1, Math.round(fx) + searchRadius);
            const minY = Math.max(0, Math.round(fy) - searchRadius);
            const maxY = Math.min(CANVAS_HEIGHT - 1, Math.round(fy) + searchRadius);

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const i = (y * CANVAS_WIDTH + x) * 4;
                    const r = imageData.data[i];
                    const g = imageData.data[i + 1];
                    const b = imageData.data[i + 2];
                    const brightness = (r + g + b) / 3;
                    const maxCh = Math.max(r, g, b);
                    const minCh = Math.min(r, g, b);
                    const saturation = maxCh > 0 ? (maxCh - minCh) / maxCh : 0;
                    // Grey: medium brightness, low saturation
                    if (brightness > 100 && brightness < 200 && saturation < 0.25) {
                        greyPixels.push({ x, y });
                    }
                }
            }

            if (greyPixels.length === 0) {
                console.log('No stick found, using figure position');
                return { x: Math.round(fx), y: Math.round(fy) };
            }

            // Step 3: Find the grey pixel furthest from figure center = stick tip
            let bestDist = 0;
            let tipX = fx, tipY = fy;
            for (const px of greyPixels) {
                const dx = px.x - fx;
                const dy = px.y - fy;
                const dist = dx * dx + dy * dy;
                if (dist > bestDist) {
                    bestDist = dist;
                    tipX = px.x;
                    tipY = px.y;
                }
            }

            console.log('Stick tip found at:', tipX, tipY, 'Grey pixels:', greyPixels.length);
            return { x: tipX, y: tipY };
        }

        function startHole(holeIndex) {
            // Reset totals when starting from menu (not via nextHole)
            if (!gameStarted) {
                totalStrokes = 0;
                totalPar = 0;
            }

            currentHoleIndex = holeIndex;
            currentHole = holes[holeIndex];

            // Load course image
            const img = new Image();
            img.onload = function() {
                courseImage = img;

                // Clear any CSS filter before capturing pixel data for detection
                canvas.style.filter = '';
                // Draw once to get image data for boundary detection
                ctx.drawImage(courseImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                courseImageData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Use hardcoded positions if set, otherwise auto-detect
                if (!currentHole.holePos) {
                    const greenPos = findPuttingGreen(courseImageData);
                    if (greenPos) {
                        currentHole.holePos = greenPos;
                        console.log('Hole position (auto-detected):', greenPos);
                    }
                } else {
                    console.log('Hole position (hardcoded):', currentHole.holePos);
                }

                if (!currentHole.ballStart) {
                    const teePos = findTeeBox(courseImageData);
                    if (teePos) {
                        currentHole.ballStart = teePos;
                        console.log('Tee box (auto-detected):', teePos);
                    }
                } else {
                    console.log('Tee box (hardcoded):', currentHole.ballStart);
                }

                // Reset game state
                resetGame();

                // Show reset button in practice, leave button in solo challenge
                document.getElementById('resetHoleBtn').style.display = gameMode === 'practice' ? 'block' : 'none';
                document.getElementById('leaveGameBtn').style.display = (gameMode === 'play' && !isMultiplayer) ? 'block' : 'none';

                // Hide start screen, show game
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('gameScreen').classList.remove('hidden');

                // Show coin balance in scoreboard if player has a name
                const coinRow = document.getElementById('coinBalanceRow');
                if (playerName) {
                    coinRow.style.display = 'flex';
                    document.getElementById('coinBalanceValue').textContent = playerCoins;
                    drawCoinIcon(document.getElementById('coinIcon'));
                } else {
                    coinRow.style.display = 'none';
                }

                gameStarted = true;
                // Carry forward music speed based on accumulated score
                const mDiff = totalStrokes - totalPar;
                const mFocus = Math.max(0, Math.min(100, 50 - mDiff * 10));
                const mFun = Math.min(100, getSwagPct() * 100);
                sendToDJ({ type: 'setGameMode', enabled: gameMusicMode, focus: mFocus, fun: mFun });
                gameLoop();
            };
            img.onerror = function() {
                console.error('Failed to load hole image:', currentHole.image);
                alert('Failed to load hole image. Please check that the image files are in the correct location.');
            };
            img.src = currentHole.image;
        }

        function resetGame() {
            ball.x = currentHole.ballStart.x;
            ball.y = currentHole.ballStart.y;
            ball.vx = 0;
            ball.vy = 0;
            ball.displayRadius = BALL_BASE_RADIUS;
            strokes = 0;
            ballMoving = false;
            shotBendActive = false;
            shotCumulativeDistance = 0;
            bendMeter = 0;
            golfer.isFixed = false;
            golfer.isSwinging = false;
            golfer.swingPhase = 'idle';
            golfer.swingAngle = 0;
            isTeeShotActive = true;
            selectedClub = 'driver';
            meterPower = 1.0;
            const btn = document.getElementById('clubBtn');
            if (btn) {
                btn.querySelector('.overlay-btn-icon').textContent = clubIcons['driver'];
                btn.querySelector('.overlay-btn-label').textContent = clubNames['driver'];
            }

            // Reset camera to full course view (driver zoom)
            cameraZoom = 1.0;
            cameraTargetZoom = 1.0;
            cameraX = CANVAS_WIDTH / 2;
            cameraY = CANVAS_HEIGHT / 2;
            cameraTargetX = CANVAS_WIDTH / 2;
            cameraTargetY = CANVAS_HEIGHT / 2;

            // Store distance from tee to hole (used for club distance caps all hole)
            holeStartDistance = Math.sqrt(
                (currentHole.ballStart.x - currentHole.holePos.x) ** 2 +
                (currentHole.ballStart.y - currentHole.holePos.y) ** 2
            );

            // Face golfer toward the hole so they stand to the side of the ball
            golfer.facingAngle = Math.atan2(
                currentHole.holePos.y - currentHole.ballStart.y,
                currentHole.holePos.x - currentHole.ballStart.x
            );

            document.getElementById('holeNumber').textContent = currentHole.name;
            document.getElementById('parValue').textContent = currentHole.par;
            updateScorePanel();

            // Reset shot/hole summary state
            shotSummaryMessages = [];
            shotBeersUsed = 0;
            shotCigsUsed = 0;
            displayBeers = 0;
            displayCigs = 0;
            shotStatsVisible = false;
            flagFrozen = false;
            holeSummaryMessages = [];
            holeBeersTotal = 0;
            holeCigsTotal = 0;

            // Wind system (practice + solo challenge + multiplayer)
            if (gameMode === 'practice' || (gameMode === 'play' && !isMultiplayer)) {
                windDirection = Math.random() < 0.5 ? -1 : 1;
                windStrength = Math.random();
                initClouds();
            } else if (isMultiplayer) {
                // Wind comes from Firebase listener (written by next-hole handler)
                initClouds();
            } else {
                windStrength = 0;
                windDirection = 1;
                clouds = [];
            }
            updateWindIndicator();
        }

        function updateScorePanel() {
            document.getElementById('strokeCount').textContent = strokes;
            document.getElementById('totalStrokesValue').textContent = totalStrokes + strokes;
            // Score to par only counts completed holes (not current hole)
            const diff = totalStrokes - totalPar;
            if (diff === 0) {
                document.getElementById('scoreToParValue').textContent = 'E';
                document.getElementById('scoreToParValue').style.color = '#ff6600';
            } else if (diff > 0) {
                document.getElementById('scoreToParValue').textContent = '+' + diff;
                document.getElementById('scoreToParValue').style.color = '#ff4444';
            } else {
                document.getElementById('scoreToParValue').textContent = '' + diff;
                document.getElementById('scoreToParValue').style.color = '#44ff44';
            }
        }

        function resetHole() {
            frozenPredictorPoints = null;
            frozenPower = null;
            frozenSwag = null;
            ballTrail = [];
            resetGame();
        }

        // ==================== EVENT LISTENERS ====================
        function setupEventListeners() {
            // Mouse: start on canvas, move/up on document so drag works off-screen
            canvas.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Touch: start on canvas, move/end on document for off-screen drag
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Powerup buttons (click-and-hold to repeat)
            setupHoldButton('beerBtn', useBeer);
            setupHoldButton('wingBtn', useWing);

            // iOS-safe tap handler: uses touchend with preventDefault to avoid
            // double-fire, falls back to click for desktop
            function onTap(el, fn) {
                el.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    fn(e);
                });
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    fn(e);
                });
            }

            // Club rotation button
            onTap(document.getElementById('clubBtn'), cycleClub);

            // Reset hole button
            onTap(document.getElementById('resetHoleBtn'), resetHole);

            // Leave game button (solo challenge)
            onTap(document.getElementById('leaveGameBtn'), () => {
                if (confirm('Leave this round? Your progress will be lost.')) {
                    returnToMenu();
                }
            });

            // Main menu button (during gameplay)
            onTap(document.getElementById('mainMenuBtn'), returnToMenu);

            // Wind control buttons (practice mode)
            document.querySelectorAll('.wind-btn').forEach(btn => {
                onTap(btn, () => setWind(parseFloat(btn.dataset.wind)));
            });

            // iPod controls ‚Äî route through DJ Stand
            onTap(document.getElementById('centerButton'), () => sendToDJ({ type: 'togglePlay' }));
            onTap(document.getElementById('playBtn'), () => sendToDJ({ type: 'togglePlay' }));
            onTap(document.getElementById('pauseBtn'), () => sendToDJ({ type: 'togglePlay' }));
            onTap(document.getElementById('prevBtn'), () => sendToDJ({ type: 'skipTrack', direction: -1 }));
            onTap(document.getElementById('nextBtn'), () => sendToDJ({ type: 'skipTrack', direction: 1 }));

            // Tap iPod screen to open DJ overlay
            onTap(document.getElementById('ipodScreen'), openDJOverlay);

            // iPod power button ‚Äî toggle game/free mix mode
            onTap(document.getElementById('ipodPowerBtn'), () => {
                gameMusicMode = !gameMusicMode;
                document.getElementById('ipodPowerBtn').classList.toggle('off', !gameMusicMode);
                if (gameMusicMode) {
                    // Just enable game mode ‚Äî don't send meters (preserves current speed/song)
                    sendToDJ({ type: 'setGameMode', enabled: true });
                } else {
                    sendToDJ({ type: 'setGameMode', enabled: false, resetDefaults: true });
                }
            });

            // DJ overlay close
            onTap(document.getElementById('djCloseBtn'), closeDJOverlay);
            document.getElementById('djOverlay').addEventListener('click', (e) => {
                if (e.target === document.getElementById('djOverlay')) closeDJOverlay();
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && djOverlayOpen) closeDJOverlay();
            });

            // Completion buttons
            document.getElementById('replayHoleBtn').addEventListener('click', replayHole);
            document.getElementById('nextHoleBtn').addEventListener('click', nextHole);
            document.getElementById('returnMenuBtn').addEventListener('click', returnToMenu);
        }

        // ==================== MOUSE/TOUCH HANDLERS ====================
        function screenCoords(e) {
            // Raw canvas-pixel coordinates (for UI hit testing)
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function canvasCoords(e) {
            // Game-world coordinates (reverse camera transform)
            const { x: sx, y: sy } = screenCoords(e);
            return {
                x: (sx - CANVAS_WIDTH / 2) / cameraZoom + cameraX,
                y: (sy - CANVAS_HEIGHT / 2) / cameraZoom + cameraY
            };
        }

        function handleMouseDown(e) {
            if (!gameStarted) return;
            if (djOverlayOpen) return;
            if (isMultiplayer && !isMyTurn) return;
            if (ballMoving) {
                // Allow spin drag during flight (driver/iron only, with existing wobble)
                if (selectedClub !== 'putter' && shotBendActive) {
                    const { x } = screenCoords(e);
                    isSpinDragging = true;
                    spinDragStartX = x;
                }
                return;
            }

            // Screen coords for UI hit testing
            const { x: sx, y: sy } = screenCoords(e);

            // Check if clicking on predictor window, fun meter, or swag meter area
            if (sx >= PREDICTOR_X && sx <= SWAG_X + SWAG_W && sy >= PREDICTOR_Y && sy <= PREDICTOR_Y + PREDICTOR_H) {
                isDraggingMeter = true;
                meterPower = Math.max(0, Math.min(1, 1 - (sy - FUN_Y) / FUN_H));
                return;
            }

            // Tap on shot stats box to hide it
            if (shotStatsVisible && sx >= STATS_X && sx <= STATS_X + STATS_SIZE && sy >= STATS_Y && sy <= STATS_Y + STATS_SIZE) {
                shotStatsVisible = false;
                return;
            }

            // Game-world coords for ball interaction
            const { x: mx, y: my } = canvasCoords(e);

            // Check if clicking near ball
            const dist = Math.sqrt((mx - ball.x) ** 2 + (my - ball.y) ** 2);
            if (dist < ball.radius + 20) {
                isDragging = true;
                peakDragDistance = 0;
                dragStartX = mx;
                dragStartY = my;
                dragEndX = mx;
                dragEndY = my;
            }
        }

        function handleMouseMove(e) {
            if (isSpinDragging && ballMoving) {
                const { x } = screenCoords(e);
                const dx = x - spinDragStartX;
                // Dead zone: only apply spin after 5px of horizontal drag
                if (Math.abs(dx) > 5) {
                    const spinAngle = (dx > 0 ? dx - 5 : dx + 5) * 0.00575;
                    shotTotalBendAngle += spinAngle;
                    if (!shotBendActive) shotBendActive = true;
                    spinDragStartX = x;
                }
                return;
            }
            if (isDraggingMeter) {
                const { y } = screenCoords(e);
                meterPower = Math.max(0, Math.min(1, 1 - (y - FUN_Y) / FUN_H));
                return;
            }
            if (!isDragging) return;

            const { x, y } = canvasCoords(e);
            dragEndX = x;
            dragEndY = y;

            // Track peak drag distance for cancel detection
            const currentDragDist = Math.sqrt((dragStartX - dragEndX) ** 2 + (dragStartY - dragEndY) ** 2);
            if (currentDragDist > peakDragDistance) peakDragDistance = currentDragDist;

            // Update power bar live when dragging with putter or iron
            if (selectedClub !== 'driver') {
                const dx = dragStartX - dragEndX;
                const dy = dragStartY - dragEndY;
                const dist = Math.sqrt(dx * dx + dy * dy) * cameraZoom;
                const maxVisibleDrag = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / (2 * cameraZoom);
                const targetDrag = maxVisibleDrag * 0.6;
                const dragDivisor = selectedClub === 'putter'
                    ? (targetDrag * cameraZoom) / (MAX_POWER * 0.67)
                    : (targetDrag * cameraZoom) / MAX_POWER;
                const rawPower = Math.min(dist / dragDivisor, MAX_POWER);
                const clubMaxSpeed = getClubMaxDistance() * (1 - FRICTION);
                const maxPutterPower = clubMaxSpeed / 0.05625;
                meterPower = Math.min(rawPower / maxPutterPower, 1);
            }
        }

        function handleMouseUp(e) {
            if (isSpinDragging) {
                isSpinDragging = false;
                return;
            }
            if (isDraggingMeter) {
                isDraggingMeter = false;
                return;
            }
            if (!isDragging) return;
            isDragging = false;
            shoot();
        }

        function handleTouchStart(e) {
            if (!gameStarted) return;
            // Only prevent default for canvas touches (allows buttons/iPod to work)
            if (e.target === canvas) {
                e.preventDefault();
            }
            const touch = e.touches[0];
            handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
        }

        function handleTouchMove(e) {
            if (!gameStarted) return;
            // Only prevent default when actively dragging
            if (isDragging || isDraggingMeter || isSpinDragging) {
                e.preventDefault();
            }
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }

        function handleTouchEnd(e) {
            if (!gameStarted) return;
            // Only prevent default when finishing a drag
            if (isDragging || isDraggingMeter || isSpinDragging) {
                e.preventDefault();
            }
            handleMouseUp({});
        }

        // ==================== SHOOTING ====================
        function shoot() {
            if (isMultiplayer && !isMyTurn) return;
            if (djOverlayOpen) return;
            if (document.getElementById('completionMessage').classList.contains('show')) return;
            if (document.getElementById('mpScorecardOverlay').style.display !== 'none') return;
            const dx = dragStartX - dragEndX;
            const dy = dragStartY - dragEndY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (selectedClub === 'driver') {
                // Driver: must pull back far enough, power from meter
                if (distance < SHOT_DRAG_THRESHOLD) return;
            } else {
                // Putter/Iron: drag distance controls power
                if (distance < 5) return;
                // Cancel if dragged back within 10% of peak distance
                if (peakDragDistance > 10 && distance < peakDragDistance * 0.10) return;
            }

            // Clear trail for new shot
            ballTrail = [];

            // Reset tree bounce and spin state
            treeBounceAscending = false;
            treeBounceDescending = false;
            isSpinDragging = false;

            // Putter/Iron use drag-based power, Driver uses meter power
            let power;
            if (selectedClub === 'driver') {
                power = MAX_POWER * meterPower;
            } else {
                // Scale dragDivisor so 100% power is reachable within ~60% of visible area
                const maxVisibleDrag = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / (2 * cameraZoom);
                const targetDrag = maxVisibleDrag * 0.6; // 60% of half-screen in world coords
                const dragDivisor = selectedClub === 'putter'
                    ? (targetDrag * cameraZoom) / (MAX_POWER * 0.67) // putter needs less range
                    : (targetDrag * cameraZoom) / MAX_POWER;
                power = Math.min((distance * cameraZoom) / dragDivisor, MAX_POWER);
                const maxClubSpeed = getClubMaxDistance() * (1 - FRICTION);
                const maxClubPower = maxClubSpeed / 0.05625;
                meterPower = Math.min(power / maxClubPower, 1); // Update visual bar
            }
            // Swag bonus: 100% swag = 20% extra power
            power *= (1 + getSwagPct() * 0.20);

            let speed = power * 0.05625;

            // Cap speed based on club max travel distance
            const clubMaxDist = getClubMaxDistance();
            const clubMaxSpeed = clubMaxDist * (1 - FRICTION);
            speed = Math.min(speed, clubMaxSpeed);

            const dirX = dx / distance;
            const dirY = dy / distance;
            const finalAngle = Math.atan2(dirY, dirX);

            ball.vx = Math.cos(finalAngle) * speed;
            ball.vy = Math.sin(finalAngle) * speed;

            // Set up bend curve parameters
            shotTotalBendAngle = (bendMeter / 5) * BEND_MAX_ANGLE * 1.30; // 30% more bend than predictor shows
            shotExpectedDistance = speed / (1 - FRICTION);
            shotCumulativeDistance = 0;
            shotPrevT = 0;
            shotBendActive = Math.abs(bendMeter) > 0;

            // Save golfer position before ball moves
            const shotAngle = finalAngle;
            const standAngle = shotAngle + Math.PI / 2;
            const offsetDist = 40;
            golfer.fixedX = ball.x + Math.cos(standAngle) * offsetDist;
            golfer.fixedY = ball.y + Math.sin(standAngle) * offsetDist;
            golfer.isFixed = true;

            // Trigger golfer swing animation
            golfer.facingAngle = finalAngle;
            golfer.swingPhase = 'backswing';
            golfer.swingAngle = 0;
            golfer.swingTimer = 0;
            golfer.isSwinging = true;

            // BOOM popup on full-power driver tee shot
            if (selectedClub === 'driver' && isTeeShotActive && meterPower >= 0.95) {
                showPowerupFeedback('BOOM!', ball.x, ball.y, 120);
            }

            // Freeze predictor path and meters before ball starts moving
            frozenPredictorPoints = computePredictorPoints();
            frozenPower = meterPower;
            frozenSwag = getSwagPct();

            // Freeze shot summary & stats
            shotSummaryMessages = [];
            displayBeers = shotBeersUsed;
            displayCigs = shotCigsUsed;
            shotBeersUsed = 0;
            shotCigsUsed = 0;
            shotStatsVisible = true;
            // Freeze flag preview if this was a tee shot
            if (isTeeShotActive) {
                frozenFlagTime = Date.now() * 0.004;
                flagFrozen = true;
            }
            const initialSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            frozenStatSpeed = initialSpeed * MPH_PER_PX_FRAME;
            frozenStatAirTime = CLUB_AIR_TIME[selectedClub] * Math.sqrt(meterPower);
            frozenStatSwag = Math.round(getSwagPct() * 100);
            frozenStatClub = selectedClub;
            frozenStatDistance = 0;

            ballMoving = true;
            isTeeShotActive = false;
            strokes++;
            updateScorePanel();

            // Broadcast shot in multiplayer
            if (isMultiplayer && currentLobby) {
                const angle = Math.atan2(ball.vy, ball.vx);
                const spd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                currentLobby.child('game/shot').set({
                    player: mySlot,
                    dirX: Math.cos(angle),
                    dirY: Math.sin(angle),
                    speed: spd,
                    bendAngle: shotTotalBendAngle,
                    club: selectedClub,
                    ballX: ball.x - ball.vx, // shot origin (before movement)
                    ballY: ball.y - ball.vy,
                    activeBall: activeBall,
                    timestamp: Date.now()
                });
                // Update my state
                currentLobby.child('game/playerStates/' + mySlot).update({
                    selectedClub: selectedClub,
                    activeBall: activeBall,
                    strokes: strokes
                });
            }
        }

        // ==================== WIND & CLOUDS ====================
        function initClouds() {
            clouds = [];
            const count = 6 + Math.floor(Math.random() * 7); // 6-12 clouds
            for (let i = 0; i < count; i++) {
                clouds.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * (CANVAS_HEIGHT * 0.65),
                    width: 90 + Math.random() * 120,
                    height: 37 + Math.random() * 45,
                    opacity: 0.25 + Math.random() * 0.35,
                    speed: (0.3 + Math.random() * 0.7) * windStrength * windDirection
                });
            }
        }

        function updateClouds() {
            if (windStrength === 0) return;
            for (const cloud of clouds) {
                cloud.x += cloud.speed;
                if (windDirection > 0 && cloud.x > CANVAS_WIDTH + cloud.width) {
                    cloud.x = -cloud.width;
                    cloud.y = Math.random() * (CANVAS_HEIGHT * 0.65);
                } else if (windDirection < 0 && cloud.x < -cloud.width) {
                    cloud.x = CANVAS_WIDTH + cloud.width;
                    cloud.y = Math.random() * (CANVAS_HEIGHT * 0.65);
                }
            }
        }

        function drawClouds() {
            if (clouds.length === 0) return;
            ctx.save();
            for (const cloud of clouds) {
                ctx.fillStyle = `rgba(255, 255, 255, ${cloud.opacity})`;
                const cw = cloud.width;
                const ch = cloud.height;
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cw * 0.4, ch * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cloud.x - cw * 0.25, cloud.y + ch * 0.1, cw * 0.3, ch * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cloud.x + cw * 0.25, cloud.y + ch * 0.1, cw * 0.3, ch * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        let windFlagAnimId = null;

        function updateWindIndicator() {
            const el = document.getElementById('windControls');
            if (!el) return;
            const hasWind = gameMode === 'practice' || gameMode === 'play' || isMultiplayer;
            const hasCoins = !!playerName;
            if (!hasWind && !hasCoins) {
                el.style.display = 'none';
                if (windFlagAnimId) { cancelAnimationFrame(windFlagAnimId); windFlagAnimId = null; }
                return;
            }
            el.style.display = 'block';
            // Show wind flag/label only when wind is active
            const windCenter = el.querySelector('[id="windFlagCanvas"]').parentElement;
            windCenter.style.display = hasWind ? 'flex' : 'none';
            // Show wind buttons only in practice mode
            const windBtns = document.getElementById('windButtons');
            if (windBtns) windBtns.style.display = (gameMode === 'practice' && !isMultiplayer) ? 'flex' : 'none';
            // Show coins or spacer
            const coinRow = document.getElementById('coinBalanceRow');
            const coinSpacer = document.getElementById('coinSpacer');
            if (hasCoins && coinRow) {
                coinRow.style.display = 'flex';
                if (coinSpacer) coinSpacer.style.display = 'none';
            } else {
                if (coinRow) coinRow.style.display = 'none';
                if (coinSpacer) coinSpacer.style.display = 'block';
            }
            if (hasWind) {
                const mph = Math.round(windStrength * 30);
                document.getElementById('windLabel').textContent = `${mph} mph`;
                startWindFlagAnimation();
            }
        }

        function startWindFlagAnimation() {
            if (windFlagAnimId) cancelAnimationFrame(windFlagAnimId);
            const flagCanvas = document.getElementById('windFlagCanvas');
            if (!flagCanvas) return;
            const fCtx = flagCanvas.getContext('2d');
            const W = flagCanvas.width;
            const H = flagCanvas.height;

            function drawFlag() {
                fCtx.clearRect(0, 0, W, H);

                // Pole
                const poleX = W / 2;
                fCtx.strokeStyle = '#666';
                fCtx.lineWidth = 2;
                fCtx.beginPath();
                fCtx.moveTo(poleX, 8);
                fCtx.lineTo(poleX, H - 2);
                fCtx.stroke();

                // Pole ball top
                fCtx.fillStyle = '#888';
                fCtx.beginPath();
                fCtx.arc(poleX, 8, 3, 0, Math.PI * 2);
                fCtx.fill();

                if (windStrength === 0) {
                    // Limp flag hanging down
                    fCtx.fillStyle = 'rgba(220, 60, 60, 0.8)';
                    fCtx.beginPath();
                    fCtx.moveTo(poleX, 10);
                    fCtx.lineTo(poleX + 3, 30);
                    fCtx.lineTo(poleX - 3, 30);
                    fCtx.lineTo(poleX, 28);
                    fCtx.lineTo(poleX, 10);
                    fCtx.fill();
                } else {
                    // Animated waving flag
                    const t = Date.now() * 0.004;
                    const dir = windDirection;
                    const flagLen = 18 + windStrength * 12; // 18-30px
                    const segments = 8;
                    const segW = flagLen / segments;
                    const flagH = 14;
                    const waveAmp = 1.5 + windStrength * 2.5; // wave amplitude

                    // Draw flag as filled shape
                    fCtx.fillStyle = 'rgba(220, 60, 60, 0.85)';
                    fCtx.beginPath();
                    // Top edge (wavy)
                    const topY = 11;
                    fCtx.moveTo(poleX, topY);
                    for (let s = 1; s <= segments; s++) {
                        const x = poleX + dir * s * segW;
                        const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8) * waveAmp;
                        fCtx.lineTo(x, topY + wave);
                    }
                    // Bottom edge (wavy, offset phase)
                    for (let s = segments; s >= 0; s--) {
                        const x = poleX + dir * s * segW;
                        const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8 + 1) * waveAmp;
                        fCtx.lineTo(x, topY + flagH + wave);
                    }
                    fCtx.closePath();
                    fCtx.fill();

                    // Flag stripe
                    fCtx.strokeStyle = 'rgba(255,255,255,0.3)';
                    fCtx.lineWidth = 1;
                    fCtx.beginPath();
                    for (let s = 0; s <= segments; s++) {
                        const x = poleX + dir * s * segW;
                        const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8 + 0.5) * waveAmp;
                        if (s === 0) fCtx.moveTo(x, topY + flagH / 2 + wave);
                        else fCtx.lineTo(x, topY + flagH / 2 + wave);
                    }
                    fCtx.stroke();
                }

                windFlagAnimId = requestAnimationFrame(drawFlag);
            }
            drawFlag();
        }

        function setWind(value) {
            // value: -1, -0.5, 0, 0.5, 1
            if (value === 0) {
                windStrength = 0;
                windDirection = 1;
            } else {
                windDirection = value > 0 ? 1 : -1;
                windStrength = Math.abs(value);
            }
            initClouds();
            updateWindIndicator();
        }

        // ==================== PHYSICS ====================
        function updateBall() {
            if (!ballMoving) return;

            // Record trail position with progress for shimmer trail
            const trailProgress = shotExpectedDistance > 0 ? Math.min(shotCumulativeDistance / shotExpectedDistance, 1) : 1;
            ballTrail.push({ x: ball.x, y: ball.y, p: trailProgress, t: Date.now() });

            const speed = Math.sqrt(ball.vx ** 2 + ball.vy ** 2);

            // Track cumulative distance for bend and size animation
            shotCumulativeDistance += speed;

            // Apply bend curve rotation to velocity
            if (shotBendActive && shotExpectedDistance > 0) {
                const t = Math.min(shotCumulativeDistance / shotExpectedDistance, 1);
                const k = BEND_K;

                if (Math.abs(shotTotalBendAngle) > 0.001) {
                    const A = shotTotalBendAngle * k / (Math.exp(k) - 1);
                    // Integrate angle change from shotPrevT to t
                    // Integral of A*e^(k*s) ds from prevT to t = (A/k)*(e^(k*t) - e^(k*prevT))
                    const dAngle = (A / k) * (Math.exp(k * t) - Math.exp(k * shotPrevT));
                    // Rotate velocity vector
                    const currentAngle = Math.atan2(ball.vy, ball.vx);
                    const newAngle = currentAngle + dAngle;
                    ball.vx = Math.cos(newAngle) * speed;
                    ball.vy = Math.sin(newAngle) * speed;
                }

                shotPrevT = t;
                if (t >= 1) shotBendActive = false;
            }

            ball.x += ball.vx;
            ball.y += ball.vy;

            // Wind effect (non-putter, ball in air)
            // Half strength while ascending (<30%) and descending (>60%), full strength 30-60%
            if (windStrength > 0 && selectedClub !== 'putter' && shotExpectedDistance > 0 && !replayingOpponentShot) {
                const progress = Math.min(shotCumulativeDistance / shotExpectedDistance, 1);
                if (progress < 0.80) {
                    const windMult = (progress < 0.30 || progress > 0.60) ? 0.5 : 1.0;
                    const windForce = windDirection * windStrength * 0.024 * windMult;
                    ball.vx += windForce;
                }
            }

            ball.vx *= FRICTION;
            ball.vy *= FRICTION;

            // Ball size animation based on travel progress (club-dependent)
            // Peak at 45% path, back to base at 90%, normal for last 10%
            if (shotExpectedDistance > 0) {
                const progress = Math.min(shotCumulativeDistance / shotExpectedDistance, 1);
                if (selectedClub === 'putter') {
                    ball.displayRadius = BALL_BASE_RADIUS; // No scaling for putter
                } else {
                    const peakMultiplier = selectedClub === 'driver' ? 1.5 : 1.0;
                    let sizeScale;
                    if (progress < 0.40) {
                        // Ascending: 0‚Üí40% maps to sin(0‚ÜíœÄ/2) = 0‚Üí1
                        sizeScale = Math.sin((progress / 0.40) * Math.PI / 2);
                    } else if (progress < 0.80) {
                        // Descending: 40%‚Üí80% maps to sin(œÄ/2‚ÜíœÄ) = 1‚Üí0
                        sizeScale = Math.sin(Math.PI / 2 + ((progress - 0.40) / 0.40) * Math.PI / 2);
                    } else {
                        // Last 20%: ground level
                        sizeScale = 0;
                    }
                    ball.displayRadius = BALL_BASE_RADIUS * (1 + peakMultiplier * sizeScale);
                }
            }

            // Tree bounce: ascending and descending phases
            // Ascending: driver 15%-70%, iron 45%-70%
            // Descending: driver 15%-70%, iron 45%-70%
            if (isTree(Math.round(ball.x), Math.round(ball.y))) {
                const maxIncrease = selectedClub === 'driver' ? 1.5 :
                                    selectedClub === 'iron' ? 1.0 : 0;
                const increase = ball.displayRadius - BALL_BASE_RADIUS;
                const progress = shotExpectedDistance > 0 ? Math.min(shotCumulativeDistance / shotExpectedDistance, 1) : 0;
                const isAscending = progress < 0.40;
                const minFrac = selectedClub === 'driver' ? 0.10 :
                                selectedClub === 'iron' ? 0.45 : 0.30;
                const maxFrac = selectedClub === 'driver' ? 0.85 : 0.70;
                const minBounce = minFrac * maxIncrease * BALL_BASE_RADIUS;
                const maxBounce = maxFrac * maxIncrease * BALL_BASE_RADIUS;
                const bounceFlag = isAscending ? !treeBounceAscending : !treeBounceDescending;

                if (increase >= minBounce && increase <= maxBounce && maxIncrease > 0 && bounceFlag) {
                    // Find bounce normal by sampling surrounding pixels
                    let nx = 0, ny = 0;
                    const sampleDist = 15;
                    const dirs = [
                        [1,0], [-1,0], [0,1], [0,-1],
                        [0.707,0.707], [-0.707,0.707], [0.707,-0.707], [-0.707,-0.707]
                    ];
                    for (const [ddx, ddy] of dirs) {
                        const sx = Math.round(ball.x + ddx * sampleDist);
                        const sy = Math.round(ball.y + ddy * sampleDist);
                        if (!isTree(sx, sy)) {
                            nx += ddx;
                            ny += ddy;
                        }
                    }

                    // Normalize
                    const nLen = Math.sqrt(nx * nx + ny * ny);
                    if (nLen > 0) {
                        nx /= nLen;
                        ny /= nLen;
                    } else {
                        // Fully inside tree ‚Äî bounce back the way we came
                        const spd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                        nx = -ball.vx / (spd || 1);
                        ny = -ball.vy / (spd || 1);
                    }

                    // Reflect velocity: v' = v - 2(v¬∑n)n, then apply 0.8 dampening
                    const dot = ball.vx * nx + ball.vy * ny;
                    ball.vx = (ball.vx - 2 * dot * nx) * 0.8;
                    ball.vy = (ball.vy - 2 * dot * ny) * 0.8;

                    // Disable bend after bounce
                    shotBendActive = false;
                    if (isAscending) treeBounceAscending = true;
                    else treeBounceDescending = true;
                    showPowerupFeedback('WHACK!', ball.x, ball.y - 20);
                }

                // Tree drag: slow ball through canopy even without bounce
                // More drag when ball is lower (descending/ground), less when high (peak)
                // sizeScale 0 = ground level (max drag), 1 = peak height (min drag)
                const heightRatio = maxIncrease > 0 ? increase / (maxIncrease * BALL_BASE_RADIUS) : 0;
                const treeDrag = selectedClub === 'driver' ? 0.97 - (1 - heightRatio) * 0.04
                               : selectedClub === 'iron' ? 0.98 - (1 - heightRatio) * 0.03
                               : 0.95; // putter rolls through trees with heavy drag
                ball.vx *= treeDrag;
                ball.vy *= treeDrag;
            } else {
                // Reset when ball leaves tree area
                treeBounceAscending = false;
                treeBounceDescending = false;
            }

            // Screen edge collisions
            checkEdgeCollision();

            // Water hazard: penalize if ball is low (size <= 1.05x base) over water
            // Tee shot (strokes === 1) skips ‚Äî ball flies high over water
            if (strokes > 1 && ball.displayRadius <= BALL_BASE_RADIUS * 1.05 && isWater(Math.round(ball.x), Math.round(ball.y))) {
                ball.vx = 0;
                ball.vy = 0;
                ballMoving = false;
                frozenPredictorPoints = null;
                frozenPower = null;
                frozenSwag = null;
                ball.displayRadius = BALL_BASE_RADIUS;
                shotBendActive = false;

                // Multiplayer: restore my state if replaying opponent
                if (isMultiplayer && replayingOpponentShot) {
                    replayingOpponentShot = false;
                    replayingSlot = null;
                    ballTrail = [];
                    if (myBallSaved) {
                        ball.x = myBallSaved.x; ball.y = myBallSaved.y;
                        activeBall = myBallSaved.activeBall;
                        selectedClub = myBallSaved.selectedClub;
                        strokes = myBallSaved.strokes;
                        cameraTargetZoom = CLUB_ZOOM[selectedClub];
                        myBallSaved = null;
                    }
                    return;
                }

                golfer.isFixed = false;
                if (isMultiplayer && isMyTurn) {
                    checkWaterHazard();
                    finalizeShotSummary();
                    onMpShotComplete();
                    return;
                }
                checkWaterHazard();
                finalizeShotSummary();
                return;
            }

            // Stop if too slow
            const currentSpeed = Math.sqrt(ball.vx ** 2 + ball.vy ** 2);
            if (currentSpeed < STOP_THRESHOLD) {
                ball.vx = 0;
                ball.vy = 0;
                ballMoving = false;
                frozenPredictorPoints = null;
                frozenPower = null;
                frozenSwag = null;
                ball.displayRadius = BALL_BASE_RADIUS;
                shotBendActive = false;

                // Multiplayer: restore my state if replaying opponent shot
                if (isMultiplayer && replayingOpponentShot) {
                    replayingOpponentShot = false;
                    replayingSlot = null;
                    ballTrail = [];
                    if (myBallSaved) {
                        ball.x = myBallSaved.x; ball.y = myBallSaved.y;
                        activeBall = myBallSaved.activeBall;
                        selectedClub = myBallSaved.selectedClub;
                        strokes = myBallSaved.strokes;
                        cameraTargetZoom = CLUB_ZOOM[selectedClub];
                        myBallSaved = null;
                    }
                    return;
                }

                // Multiplayer: my shot completed
                if (isMultiplayer && isMyTurn) {
                    // Check hazards first (may add penalty + reposition)
                    checkWhiteHazard();

                    // Check if holed (snap ball to hole)
                    const hDist = Math.sqrt(
                        (ball.x - currentHole.holePos.x) ** 2 +
                        (ball.y - currentHole.holePos.y) ** 2
                    );
                    if (hDist < holeRadius) {
                        ball.x = currentHole.holePos.x;
                        ball.y = currentHole.holePos.y;
                        const underPar = Math.max(0, currentHole.par - strokes);
                        spawnHoleFireworks(ball.x, ball.y, underPar);
                        shotSummaryMessages.push('HOLED!');
                        if (underPar > 0) {
                            showPowerupFeedback(`+${underPar} BS Coin${underPar > 1 ? 's' : ''}!`, ball.x, ball.y - 25, 300);
                        }
                    }
                    golfer.isFixed = false;
                    finalizeShotSummary();
                    onMpShotComplete();
                    return;
                }

                // Solo: Check hole ONLY when ball comes to rest
                if (checkHoleIn()) return;

                // Teleport golfer to ball
                golfer.isFixed = false;

                // Check hazards
                checkWaterHazard();
                checkWhiteHazard();
                finalizeShotSummary();
            }
        }

        // Detect if pixel is white (course boundary)
        function isCourseEdge(x, y) {
            if (!courseImageData) return false;
            
            x = Math.round(x);
            y = Math.round(y);
            
            if (x < 0 || x >= CANVAS_WIDTH || y < 0 || y >= CANVAS_HEIGHT) return true;
            
            const index = (y * CANVAS_WIDTH + x) * 4;
            const r = courseImageData.data[index];
            const g = courseImageData.data[index + 1];
            const b = courseImageData.data[index + 2];
            
            // White threshold - adjust if needed
            const threshold = 200;
            return r > threshold && g > threshold && b > threshold;
        }

        function isWater(x, y) {
            if (!courseImageData) return false;
            x = Math.round(x);
            y = Math.round(y);
            if (x < 0 || x >= CANVAS_WIDTH || y < 0 || y >= CANVAS_HEIGHT) return false;
            const i = (y * CANVAS_WIDTH + x) * 4;
            const r = courseImageData.data[i];
            const g = courseImageData.data[i + 1];
            const b = courseImageData.data[i + 2];
            // Blue water: high blue, lower red and green
            return b > 150 && r < 120 && g < 180 && b > r && b > g;
        }

        function isGrass(x, y) {
            if (!courseImageData) return false;
            x = Math.round(x);
            y = Math.round(y);
            if (x < 0 || x >= CANVAS_WIDTH || y < 0 || y >= CANVAS_HEIGHT) return false;
            const i = (y * CANVAS_WIDTH + x) * 4;
            const r = courseImageData.data[i];
            const g = courseImageData.data[i + 1];
            const b = courseImageData.data[i + 2];
            // Green grass: high green, lower red and blue
            return g > 80 && g > r && g > b;
        }

        function isTree(x, y) {
            if (!courseImageData) return false;
            x = Math.round(x);
            y = Math.round(y);
            if (x < 0 || x >= CANVAS_WIDTH || y < 0 || y >= CANVAS_HEIGHT) return false;
            const i = (y * CANVAS_WIDTH + x) * 4;
            const r = courseImageData.data[i];
            const g = courseImageData.data[i + 1];
            const b = courseImageData.data[i + 2];
            // Dark green: green dominant, low overall brightness
            return g > 40 && g > r && g > b && (r + g + b) < 200 && r < 80;
        }

        function checkWaterHazard() {
            // Sample points within ball radius to check water coverage
            const sampleRadius = ball.displayRadius || BALL_BASE_RADIUS;
            let waterCount = 0;
            let totalCount = 0;

            for (let dy = -sampleRadius; dy <= sampleRadius; dy += 2) {
                for (let dx = -sampleRadius; dx <= sampleRadius; dx += 2) {
                    if (dx * dx + dy * dy <= sampleRadius * sampleRadius) {
                        totalCount++;
                        if (isWater(ball.x + dx, ball.y + dy)) {
                            waterCount++;
                        }
                    }
                }
            }

            if (totalCount > 0 && waterCount / totalCount > 0.5) {
                // Find closest grass pixel using expanding search
                let found = false;
                for (let radius = 1; radius < 200 && !found; radius += 2) {
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
                        const checkX = Math.round(ball.x + Math.cos(angle) * radius);
                        const checkY = Math.round(ball.y + Math.sin(angle) * radius);
                        if (isGrass(checkX, checkY)) {
                            ball.x = checkX;
                            ball.y = checkY;
                            found = true;
                            break;
                        }
                    }
                }

                // Add penalty stroke
                strokes++;
                updateScorePanel();
                showPowerupFeedback('WATER +1 Stroke', ball.x, ball.y - 30);
            }
        }

        function checkWhiteHazard() {
            // Skip if ball is near the hole (putting green may have light pixels)
            if (currentHole && currentHole.holePos) {
                const dx = ball.x - currentHole.holePos.x;
                const dy = ball.y - currentHole.holePos.y;
                if (Math.sqrt(dx * dx + dy * dy) < holeRadius * 4) return;
            }

            // Sample points within ball radius to check white coverage
            const sampleRadius = ball.displayRadius || BALL_BASE_RADIUS;
            let whiteCount = 0;
            let totalCount = 0;

            for (let dy = -sampleRadius; dy <= sampleRadius; dy += 2) {
                for (let dx = -sampleRadius; dx <= sampleRadius; dx += 2) {
                    if (dx * dx + dy * dy <= sampleRadius * sampleRadius) {
                        totalCount++;
                        if (isCourseEdge(ball.x + dx, ball.y + dy)) {
                            whiteCount++;
                        }
                    }
                }
            }

            if (totalCount > 0 && whiteCount / totalCount > 0.5) {
                // Find closest grass pixel using expanding search
                let found = false;
                for (let radius = 1; radius < 200 && !found; radius += 2) {
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
                        const checkX = Math.round(ball.x + Math.cos(angle) * radius);
                        const checkY = Math.round(ball.y + Math.sin(angle) * radius);
                        if (isGrass(checkX, checkY)) {
                            ball.x = checkX;
                            ball.y = checkY;
                            found = true;
                            break;
                        }
                    }
                }

                // Add penalty stroke
                strokes++;
                foulHighlightTimer = 180; // ~3 seconds at 60fps
                updateScorePanel();
                showPowerupFeedback('OUT OF BOUNDS +1', ball.x, ball.y - 30);
            }
        }

        function checkBoundaryCollision() {
            // Sample 16 points around the ball to build a surface normal
            const checkPoints = 16;
            let normalX = 0;
            let normalY = 0;
            let collisionCount = 0;

            for (let i = 0; i < checkPoints; i++) {
                const angle = (i / checkPoints) * Math.PI * 2;
                const checkX = ball.x + Math.cos(angle) * (ball.displayRadius + 2);
                const checkY = ball.y + Math.sin(angle) * (ball.displayRadius + 2);

                if (isCourseEdge(checkX, checkY)) {
                    // Each hit point contributes to the average normal
                    normalX += ball.x - checkX;
                    normalY += ball.y - checkY;
                    collisionCount++;
                }
            }

            if (collisionCount > 0) {
                // Normalize the collision normal
                const len = Math.sqrt(normalX * normalX + normalY * normalY);
                if (len > 0) {
                    normalX /= len;
                    normalY /= len;
                }

                // Reflect velocity: v' = v - 2(v¬∑n)n
                const dot = ball.vx * normalX + ball.vy * normalY;

                // Only reflect if moving into the wall
                if (dot < 0) {
                    ball.vx -= 2 * dot * normalX;
                    ball.vy -= 2 * dot * normalY;

                    // Cushion dampening (like pool rails)
                    ball.vx *= 0.82;
                    ball.vy *= 0.82;
                }

                // Push ball out of the wall
                ball.x += normalX * 3;
                ball.y += normalY * 3;
            }
        }

        function checkEdgeCollision() {
            const dampening = 0.82;
            const r = ball.displayRadius;

            if (ball.x - r < 0) {
                ball.x = r;
                ball.vx = Math.abs(ball.vx) * dampening;
                ball.vy *= dampening;
            } else if (ball.x + r > CANVAS_WIDTH) {
                ball.x = CANVAS_WIDTH - r;
                ball.vx = -Math.abs(ball.vx) * dampening;
                ball.vy *= dampening;
            }

            if (ball.y - r < 0) {
                ball.y = r;
                ball.vy = Math.abs(ball.vy) * dampening;
                ball.vx *= dampening;
            } else if (ball.y + r > CANVAS_HEIGHT) {
                ball.y = CANVAS_HEIGHT - r;
                ball.vy = -Math.abs(ball.vy) * dampening;
                ball.vx *= dampening;
            }
        }

        function checkHoleIn() {
            const dist = Math.sqrt(
                (ball.x - currentHole.holePos.x) ** 2 +
                (ball.y - currentHole.holePos.y) ** 2
            );

            // Ball must have 50%+ overlap with hole when at rest
            // Overlap > 50% means center distance < holeRadius
            if (dist < holeRadius) {
                ball.x = currentHole.holePos.x;
                ball.y = currentHole.holePos.y;
                const underPar = Math.max(0, currentHole.par - strokes);
                spawnHoleFireworks(ball.x, ball.y, underPar);
                shotSummaryMessages.push('HOLED!');
                if (underPar > 0) {
                    showPowerupFeedback(`+${underPar} BS Coin${underPar > 1 ? 's' : ''}!`, ball.x, ball.y - 25, 300);
                }
                finalizeShotSummary();
                showCompletion();
                return true;
            }
            return false;
        }

        function showCompletion() {
            const msg = document.getElementById('completionMessage');
            const title = document.getElementById('completionTitle');
            const strokesText = document.getElementById('completionStrokes');
            const scoreToPar = document.getElementById('completionScoreToPar');
            const nextBtn = document.getElementById('nextHoleBtn');
            const diff = strokes - currentHole.par;

            // Accumulate totals
            totalStrokes += strokes;
            totalPar += currentHole.par;

            // Hole summary on completion screen
            const summaryDiv = document.getElementById('completionSummary');
            const summaryParts = [];
            if (holeSummaryMessages.length > 0) {
                // Deduplicate: show count for repeated messages
                const counts = {};
                holeSummaryMessages.forEach(m => { counts[m] = (counts[m] || 0) + 1; });
                Object.entries(counts).forEach(([m, c]) => {
                    summaryParts.push(c > 1 ? `${m} x${c}` : m);
                });
            }
            if (holeBeersTotal > 0) summaryParts.push('Beers: ' + holeBeersTotal);
            if (holeCigsTotal > 0) summaryParts.push('Cigs: ' + holeCigsTotal);
            if (summaryParts.length > 0) {
                summaryDiv.textContent = summaryParts.join(' | ');
                summaryDiv.style.display = 'block';
            } else {
                summaryDiv.style.display = 'none';
            }

            // Award bottom shelf coins (1 per stroke under par)
            const coinsDiv = document.getElementById('completionCoins');
            if (diff < 0 && playerName) {
                const earned = Math.abs(diff);
                playerCoins += earned;
                savePlayerData();
                // Show coins earned
                document.getElementById('completionCoinsText').textContent = `+${earned} Bottom Shelf Coin${earned > 1 ? 's' : ''}`;
                drawCoinIcon(document.getElementById('completionCoinIcon'));
                coinsDiv.style.display = 'block';
                // Update scoreboard balance
                document.getElementById('coinBalanceValue').textContent = playerCoins;
            } else {
                coinsDiv.style.display = 'none';
            }

            if (strokes === 1) {
                title.textContent = 'HOLE IN ONE!';
            } else if (diff <= -2) {
                title.textContent = 'Eagle!';
            } else if (diff === -1) {
                title.textContent = 'Birdie!';
            } else if (diff === 0) {
                title.textContent = 'Par';
            } else if (diff === 1) {
                title.textContent = 'Bogey';
            } else if (diff === 2) {
                title.textContent = 'Double Bogey';
            } else if (diff === 3) {
                title.textContent = 'Triple Bogey';
            } else {
                title.textContent = 'A Lot Over Par';
            }

            strokesText.textContent = strokes + (strokes === 1 ? ' stroke' : ' strokes');

            // Score to par display
            const totalDiff = totalStrokes - totalPar;
            if (totalDiff === 0) {
                scoreToPar.textContent = 'Score to Par: E';
                scoreToPar.style.color = '#8f8';
            } else if (totalDiff > 0) {
                scoreToPar.textContent = 'Score to Par: +' + totalDiff;
                scoreToPar.style.color = '#f88';
            } else {
                scoreToPar.textContent = 'Score to Par: ' + totalDiff;
                scoreToPar.style.color = '#8f8';
            }

            // Show replay button only in practice mode
            document.getElementById('replayHoleBtn').style.display = gameMode === 'practice' ? 'block' : 'none';

            // Hide "next hole" on last hole
            const isLastHole = currentHoleIndex >= holes.length - 1;
            nextBtn.style.display = isLastHole ? 'none' : 'block';

            // In play mode on last hole, save to leaderboard and show it
            if (gameMode === 'play' && isLastHole && !isMultiplayer && playerName) {
                const entry = addLeaderboardEntry(playerName, totalStrokes - totalPar);
                renderLeaderboard(entry);
            }

            msg.classList.add('show');

            // Save individual hole score to Firebase
            saveScore();
        }

        function replayHole() {
            document.getElementById('completionMessage').classList.remove('show');
            // Undo the totals accumulated in showCompletion so replay doesn't double-count
            totalStrokes -= strokes;
            totalPar -= currentHole.par;
            startHole(currentHoleIndex);
        }

        function nextHole() {
            document.getElementById('completionMessage').classList.remove('show');
            // Carry over strokes: totalStrokes already updated in showCompletion
            const nextIndex = currentHoleIndex + 1;
            if (nextIndex < holes.length) {
                startHole(nextIndex);
            }
        }

        function returnToMenu() {
            if (djOverlayOpen) closeDJOverlay();
            document.querySelectorAll('.powerup-feedback').forEach(el => el.remove());
            document.getElementById('completionMessage').classList.remove('show');
            document.getElementById('leaderboardSection').style.display = 'none';
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            // Reset start screen to mode selection
            document.getElementById('modeSelect').style.display = 'flex';
            document.getElementById('playModeSelect').style.display = 'none';
            document.getElementById('nameEntry').style.display = 'none';
            document.getElementById('holeGrid').style.display = 'none';
            document.getElementById('proShopScreen').style.display = 'none';
            document.getElementById('playerNameInput').value = '';
            gameStarted = false;
            totalStrokes = 0;
            totalPar = 0;
            sendToDJ({ type: 'setGameMode', enabled: false, resetDefaults: true });
            gameMusicMode = false;
            document.getElementById('ipodPowerBtn').classList.add('off');

            // Cleanup multiplayer
            if (isMultiplayer) {
                cleanupMpGame();
                cleanupMpLobby();
                isMultiplayer = false;
                isMyTurn = false;
                replayingOpponentShot = false;
                replayingSlot = null;
                myBallSaved = null;
                document.getElementById('mpHUD').style.display = 'none';
                document.getElementById('mpReactionBar').style.display = 'none';
                document.getElementById('mpScorecardOverlay').style.display = 'none';
            }

            // Keep player info visible if name is set
            if (playerName) {
                document.getElementById('mainNameEntry').style.display = 'none';
                document.getElementById('playerInfo').style.display = 'block';
                updatePlayerUI();
            } else {
                document.getElementById('mainNameEntry').style.display = 'block';
                document.getElementById('playerInfo').style.display = 'none';
            }
        }

        // ==================== POWERUPS ====================
        function setupHoldButton(id, action) {
            const el = document.getElementById(id);
            let holdInterval = null;
            function startHold() {
                action();
                holdInterval = setInterval(action, 100);
            }
            function stopHold() {
                if (holdInterval) { clearInterval(holdInterval); holdInterval = null; }
            }
            el.addEventListener('mousedown', (e) => { e.preventDefault(); startHold(); });
            el.addEventListener('mouseup', stopHold);
            el.addEventListener('mouseleave', stopHold);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); });
            el.addEventListener('touchend', stopHold);
            el.addEventListener('touchcancel', stopHold);
        }

        function useBeer() {
            if (isMultiplayer && !isMyTurn) return;
            if (ballMoving) return;
            bendMeter = Math.min(5, bendMeter + 1);
            shotBeersUsed++;
            displayBeers = shotBeersUsed;
            holeBeersTotal++;
            showPowerupFeedback('Glug', dragEndX || canvas.width / 2, dragEndY || canvas.height / 2);
        }

        function useWing() {
            if (isMultiplayer && !isMyTurn) return;
            if (ballMoving) return;
            bendMeter = Math.max(-5, bendMeter - 1);
            shotCigsUsed++;
            displayCigs = shotCigsUsed;
            holeCigsTotal++;
            showPowerupFeedback('Chomp', dragEndX || canvas.width / 2, dragEndY || canvas.height / 2);
        }

        const clubOrder = ['driver', 'iron', 'putter'];
        const clubIcons = { driver: 'üèåÔ∏è', iron: '‚õ≥', putter: 'üèí' };
        const clubNames = { driver: 'DRIVER', iron: 'IRON', putter: 'PUTTER' };

        function cycleClub() {
            const idx = clubOrder.indexOf(selectedClub);
            selectedClub = clubOrder[(idx + 1) % clubOrder.length];
            meterPower = selectedClub === 'driver' ? 1.0 : selectedClub === 'iron' ? 0.65 : 0.35;
            const btn = document.getElementById('clubBtn');
            btn.querySelector('.overlay-btn-icon').textContent = clubIcons[selectedClub];
            btn.querySelector('.overlay-btn-label').textContent = clubNames[selectedClub];
        }

        // Get max travel distance for current club based on tee-to-hole distance
        function getClubMaxDistance() {
            return holeStartDistance * CLUB_DISTANCE_FRACTION[selectedClub];
        }

        function showPowerupFeedback(text, x, y, frames, extraClass) {
            // Collect into shot summary (skip MP reactions and powerup use messages)
            if (extraClass !== 'mp-reaction' && !replayingOpponentShot && text !== 'Glug' && text !== 'Chomp') {
                // Limit WHACK! to 2 per shot
                if (text === 'WHACK!' && shotSummaryMessages.filter(m => m === 'WHACK!').length >= 2) {
                    // Skip ‚Äî already have 2 WHACK! messages this shot
                } else {
                    shotSummaryMessages.push(text);
                    holeSummaryMessages.push(text);
                }
            }
            // Collect MP reactions into chat box
            if (extraClass === 'mp-reaction') {
                mpChatMessages.push({ text, time: Date.now() });
                if (mpChatMessages.length > 5) mpChatMessages.shift();
            }

            // Only show floating popup for MP reactions ‚Äî all other messages go to summary box only
            if (extraClass !== 'mp-reaction') return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / CANVAS_WIDTH;
            const scaleY = rect.height / CANVAS_HEIGHT;

            const screenX = (x - cameraX) * cameraZoom + CANVAS_WIDTH / 2;
            const screenY = (y - cameraY) * cameraZoom + CANVAS_HEIGHT / 2;

            const feedback = document.createElement('div');
            feedback.className = 'powerup-feedback mp-reaction';
            feedback.textContent = text;
            feedback.style.left = (rect.left + screenX * scaleX + window.scrollX) + 'px';
            feedback.style.top = (rect.top + screenY * scaleY + window.scrollY) + 'px';
            document.body.appendChild(feedback);

            setTimeout(() => feedback.remove(), 4000);
        }

        // ==================== DJ STAND BRIDGE ====================
        function sendToDJ(data) {
            if (djFrame && djFrame.contentWindow) {
                djFrame.contentWindow.postMessage(data, '*');
            }
        }

        window.addEventListener('message', (e) => {
            if (e.data && e.data.type === 'trackChanged') {
                currentSongName = e.data.name || '---';
                updateIPodDisplay();
            }
        });

        function updateIPodDisplay() {
            document.getElementById('songDisplay').textContent = currentSongName;
        }

        function openDJOverlay() {
            document.getElementById('djOverlay').classList.add('show');
            djOverlayOpen = true;
        }

        function closeDJOverlay() {
            document.getElementById('djOverlay').classList.remove('show');
            djOverlayOpen = false;
        }

        function updateMusicSpeed() {
            if (!gameMusicMode) return; // free mix mode ‚Äî don't override faders
            const diff = totalStrokes - totalPar;
            const focus = Math.max(0, Math.min(100, 50 - diff * 10));
            const fun = Math.min(100, getSwagPct() * 100);
            sendToDJ({ type: 'gameMeters', focus: focus, fun: fun });
        }

        // ==================== DRAWING ====================
        function drawCourse() {
            if (courseImage) {
                ctx.drawImage(courseImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }
        }

        function spawnHoleFireworks(x, y, underPar) {
            // underPar: number of strokes under par (1=birdie, 2=eagle, etc). 0 = par
            const intensity = Math.max(1, (underPar || 0) + 1); // par=1x, birdie=2x, eagle=3x, HIO on par3=4x
            const count = Math.floor(25 * intensity);
            const speedMult = 0.8 + intensity * 0.4;
            const lifeMult = 0.7 + intensity * 0.3;
            const colors = ['#cc0000', '#e63333', '#8b1a1a', '#ff4444', '#a02020', '#d44', '#ff6666'];
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (1.5 + Math.random() * 4) * speedMult;
                const baseLife = 60 + Math.floor(Math.random() * 50);
                fireworkParticles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2 * speedMult,
                    life: Math.floor(baseLife * lifeMult),
                    maxLife: Math.floor(baseLife * lifeMult),
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: 2 + Math.random() * 3 + (intensity - 1) * 0.5,
                    gravity: 0.04 + Math.random() * 0.03
                });
            }

        }

        function updateFireworks() {
            for (let i = fireworkParticles.length - 1; i >= 0; i--) {
                const p = fireworkParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity;
                p.vx *= 0.98;
                p.life--;
                if (p.life <= 0) fireworkParticles.splice(i, 1);
            }
        }

        function drawFireworks() {
            if (fireworkParticles.length === 0) return;
            ctx.save();
            for (const p of fireworkParticles) {
                const alpha = p.life / p.maxLife;
                const fade = Math.min(1, alpha * 2);
                ctx.globalAlpha = fade;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 6;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawBall() {
            // Pulsating yellow glow around ball (always visible, helps locate ball)
            if (!replayingOpponentShot) {
                const glowPulse = 0.4 + 0.6 * Math.sin(Date.now() * 0.004);
                ctx.save();
                ctx.shadowColor = `rgba(255, 215, 0, ${0.3 + glowPulse * 0.4})`;
                ctx.shadowBlur = 8 + glowPulse * 6;
                ctx.fillStyle = 'rgba(255, 215, 0, 0)';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.displayRadius + 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Pulsating red border for tee shot (not during opponent replay)
            if (isTeeShotActive && !ballMoving && !replayingOpponentShot) {
                const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.006);
                const pulseRadius = ball.displayRadius + 4 + pulse * 3;
                ctx.save();
                ctx.strokeStyle = `rgba(255, 0, 0, ${0.5 + pulse * 0.5})`;
                ctx.lineWidth = 2 + pulse;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Pulsing foul highlight after OOB (not during opponent replay)
            if (foulHighlightTimer > 0 && !ballMoving && !replayingOpponentShot) {
                foulHighlightTimer--;
                const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.008);
                const pulseRadius = ball.displayRadius + 6 + pulse * 4;
                ctx.save();
                ctx.strokeStyle = `rgba(255, 200, 0, ${0.4 + pulse * 0.6})`;
                ctx.lineWidth = 2 + pulse * 2;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Pulsating halo matching ball color/pattern (always visible)
            if (!replayingOpponentShot) {
                const haloPulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.004);
                const haloRadius = ball.displayRadius + 5 + haloPulse * 4;
                ctx.save();
                let haloColor;
                if (activeBall === 'diamondBall') {
                    haloColor = `rgba(160, 216, 255, ${0.3 + haloPulse * 0.4})`;
                } else if (activeBall === 'goldBall') {
                    haloColor = `rgba(255, 215, 0, ${0.3 + haloPulse * 0.4})`;
                } else if (activeBall === 'eightBall') {
                    haloColor = `rgba(80, 0, 120, ${0.3 + haloPulse * 0.4})`;
                } else if (activeBall === 'camoBall') {
                    haloColor = `rgba(85, 107, 47, ${0.3 + haloPulse * 0.4})`;
                } else {
                    haloColor = `rgba(255, 255, 255, ${0.25 + haloPulse * 0.35})`;
                }
                const haloGrd = ctx.createRadialGradient(
                    ball.x, ball.y, ball.displayRadius * 0.8,
                    ball.x, ball.y, haloRadius
                );
                haloGrd.addColorStop(0, haloColor);
                haloGrd.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = haloGrd;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, haloRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Main ball
            const r = ball.displayRadius;
            if (activeBall === 'diamondBall') {
                const grd = ctx.createRadialGradient(
                    ball.x - r * 0.3, ball.y - r * 0.35, r * 0.1,
                    ball.x, ball.y, r
                );
                grd.addColorStop(0, '#FFFFFF');
                grd.addColorStop(0.3, '#E0F0FF');
                grd.addColorStop(0.6, '#A0D8FF');
                grd.addColorStop(1, '#6BB8E8');
                ctx.fillStyle = grd;
                ctx.shadowColor = 'rgba(160, 216, 255, 0.6)';
                ctx.shadowBlur = 12;
            } else if (activeBall === 'goldBall') {
                const grd = ctx.createRadialGradient(
                    ball.x - r * 0.3, ball.y - r * 0.35, r * 0.1,
                    ball.x, ball.y, r
                );
                grd.addColorStop(0, '#FFF6A0');
                grd.addColorStop(0.4, '#FFD700');
                grd.addColorStop(1, '#B8860B');
                ctx.fillStyle = grd;
                ctx.shadowColor = 'rgba(255, 215, 0, 0.4)';
                ctx.shadowBlur = 10;
            } else if (activeBall === 'eightBall') {
                ctx.fillStyle = '#111';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
                ctx.shadowBlur = 10;
            } else if (activeBall === 'camoBall') {
                ctx.fillStyle = '#556B2F';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
            } else {
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
            }
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // 8-ball details
            if (activeBall === 'eightBall') {
                ctx.save();
                // White circle
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y - r * 0.05, r * 0.48, 0, Math.PI * 2);
                ctx.fill();
                // Number 8
                ctx.fillStyle = '#111';
                ctx.font = `bold ${r * 0.65}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('8', ball.x, ball.y - r * 0.02);
                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.ellipse(ball.x - r * 0.25, ball.y - r * 0.3, r * 0.3, r * 0.15, -0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Camo ball details
            if (activeBall === 'camoBall') {
                ctx.save();
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, r, 0, Math.PI * 2);
                ctx.clip();
                // Dark green patches
                ctx.fillStyle = '#2E4E1E';
                ctx.beginPath(); ctx.ellipse(ball.x - r * 0.4, ball.y - r * 0.3, r * 0.5, r * 0.35, 0.4, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(ball.x + r * 0.4, ball.y + r * 0.3, r * 0.4, r * 0.3, -0.6, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(ball.x, ball.y + r * 0.6, r * 0.35, r * 0.25, 0.2, 0, Math.PI * 2); ctx.fill();
                // Tan/khaki patches
                ctx.fillStyle = '#8B7D3C';
                ctx.beginPath(); ctx.ellipse(ball.x + r * 0.2, ball.y - r * 0.3, r * 0.38, r * 0.28, -0.3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(ball.x - r * 0.45, ball.y + r * 0.3, r * 0.35, r * 0.25, 0.5, 0, Math.PI * 2); ctx.fill();
                // Dark brown patches
                ctx.fillStyle = '#3B3518';
                ctx.beginPath(); ctx.ellipse(ball.x - r * 0.15, ball.y + r * 0.05, r * 0.3, r * 0.2, 0.8, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(ball.x + r * 0.3, ball.y - r * 0.15, r * 0.25, r * 0.18, -0.4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.25)';
                ctx.beginPath();
                ctx.ellipse(ball.x - r * 0.25, ball.y - r * 0.3, r * 0.3, r * 0.15, -0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Shine highlight + animated shimmer (gold & diamond)
            if (activeBall === 'goldBall' || activeBall === 'diamondBall') {
                const isDiamond = activeBall === 'diamondBall';
                const t = Date.now();
                ctx.save();

                // Static shine highlight
                ctx.fillStyle = isDiamond ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.ellipse(ball.x - r * 0.25, ball.y - r * 0.3, r * 0.35, r * 0.2, -0.5, 0, Math.PI * 2);
                ctx.fill();

                // Animated shimmer ‚Äî rotating sparkle points around the ball
                const shimmerCount = isDiamond ? 6 : 3;
                for (let i = 0; i < shimmerCount; i++) {
                    const angle = (t * 0.003) + (i * Math.PI * 2 / shimmerCount);
                    const dist = r * (0.5 + 0.3 * Math.sin(t * 0.004 + i * 1.5));
                    const sx = ball.x + Math.cos(angle) * dist;
                    const sy = ball.y + Math.sin(angle) * dist;
                    const flicker = 0.3 + 0.7 * Math.abs(Math.sin(t * 0.006 + i * 2.1));
                    const size = r * (isDiamond ? 0.14 : 0.1) * flicker;

                    // Draw 4-point star sparkle
                    ctx.fillStyle = isDiamond
                        ? `rgba(255,255,255,${flicker * 0.8})`
                        : `rgba(255,248,180,${flicker * 0.6})`;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy - size);
                    ctx.lineTo(sx + size * 0.3, sy);
                    ctx.lineTo(sx, sy + size);
                    ctx.lineTo(sx - size * 0.3, sy);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(sx - size, sy);
                    ctx.lineTo(sx, sy + size * 0.3);
                    ctx.lineTo(sx + size, sy);
                    ctx.lineTo(sx, sy - size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        function drawHole() {
            // Transparent scoring circle around the red flag
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(currentHole.holePos.x, currentHole.holePos.y, holeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Flag pole and waving flag ‚Äî mirrors the wind flag exactly
            const hx = currentHole.holePos.x;
            const hy = currentHole.holePos.y;
            const poleH = 50;

            ctx.save();
            // Pole
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(hx, hy - poleH);
            ctx.stroke();

            // Pole ball on top
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(hx, hy - poleH, 3, 0, Math.PI * 2);
            ctx.fill();

            if (windStrength === 0) {
                // Limp flag hanging down (same as wind flag)
                ctx.fillStyle = 'rgba(220, 60, 60, 0.8)';
                ctx.beginPath();
                ctx.moveTo(hx, hy - poleH + 2);
                ctx.lineTo(hx + 3, hy - poleH + 22);
                ctx.lineTo(hx - 3, hy - poleH + 22);
                ctx.lineTo(hx, hy - poleH + 20);
                ctx.lineTo(hx, hy - poleH + 2);
                ctx.fill();
            } else {
                // Animated waving flag ‚Äî same math as wind flag
                const t = Date.now() * 0.004;
                const dir = windDirection;
                const flagLen = 18 + windStrength * 12;
                const segments = 8;
                const segW = flagLen / segments;
                const flagH = 14;
                const waveAmp = 1.5 + windStrength * 2.5;
                const topY = hy - poleH + 2;

                ctx.fillStyle = 'rgba(220, 60, 60, 0.85)';
                ctx.beginPath();
                ctx.moveTo(hx, topY);
                for (let s = 1; s <= segments; s++) {
                    const fx = hx + dir * s * segW;
                    const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8) * waveAmp;
                    ctx.lineTo(fx, topY + wave);
                }
                for (let s = segments; s >= 0; s--) {
                    const fx = hx + dir * s * segW;
                    const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8 + 1) * waveAmp;
                    ctx.lineTo(fx, topY + flagH + wave);
                }
                ctx.closePath();
                ctx.fill();

                // Flag stripe
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let s = 0; s <= segments; s++) {
                    const fx = hx + dir * s * segW;
                    const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8 + 0.5) * waveAmp;
                    if (s === 0) ctx.moveTo(fx, topY + flagH / 2 + wave);
                    else ctx.lineTo(fx, topY + flagH / 2 + wave);
                }
                ctx.stroke();
            }
            ctx.restore();
        }

        // ==================== GOLFER CHARACTER ====================
        function updateGolfer() {
            if (!golfer.isSwinging) return;

            golfer.swingTimer++;

            if (golfer.swingPhase === 'backswing') {
                golfer.swingAngle -= 0.15;
                if (golfer.swingAngle <= -1.2) {
                    golfer.swingPhase = 'downswing';
                }
            } else if (golfer.swingPhase === 'downswing') {
                golfer.swingAngle += 0.3;
                if (golfer.swingAngle >= 1.5) {
                    golfer.swingPhase = 'followthrough';
                }
            } else if (golfer.swingPhase === 'followthrough') {
                golfer.swingAngle += 0.02;
                if (golfer.swingTimer > 40) {
                    golfer.swingPhase = 'reset';
                }
            } else if (golfer.swingPhase === 'reset') {
                golfer.swingAngle *= 0.85;
                if (Math.abs(golfer.swingAngle) < 0.05) {
                    golfer.swingAngle = 0;
                    golfer.isSwinging = false;
                    golfer.swingPhase = 'idle';
                }
            }
        }

        function drawGolfer() {
            // Only show golfer after a shot is taken (while ball is moving)
            if (!ballMoving) return;

            const shotAngle = isDragging
                ? Math.atan2(dragStartY - dragEndY, dragStartX - dragEndX)
                : golfer.facingAngle;
            const standAngle = shotAngle + Math.PI / 2;

            let gx, gy;

            if (golfer.isFixed) {
                // Stay at stored position while ball is moving
                gx = golfer.fixedX;
                gy = golfer.fixedY;
            } else {
                // Position golfer offset from the ball
                const offsetDist = 40;
                gx = ball.x + Math.cos(standAngle) * offsetDist;
                gy = ball.y + Math.sin(standAngle) * offsetDist;
            }

            ctx.save();
            ctx.translate(gx, gy);

            // Scale factor
            const s = 1.0;

            // --- HEAD ---
            ctx.fillStyle = '#ffcc88';
            ctx.beginPath();
            ctx.arc(0, -28 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Hat
            ctx.fillStyle = '#cc3333';
            ctx.beginPath();
            ctx.ellipse(0, -34 * s, 10 * s, 4 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(-6 * s, -38 * s, 12 * s, 6 * s);

            // --- BODY ---
            ctx.strokeStyle = '#336633';
            ctx.lineWidth = 4 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, -20 * s);
            ctx.lineTo(0, 5 * s);
            ctx.stroke();

            // --- LEGS ---
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(0, 5 * s);
            ctx.lineTo(-6 * s, 22 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, 5 * s);
            ctx.lineTo(6 * s, 22 * s);
            ctx.stroke();

            // --- ARMS + CLUB ---
            const handY = -10 * s;
            const clubLen = 35 * s;

            // Determine club angle
            let clubAngle;
            if (golfer.isSwinging) {
                // Swing animation ‚Äî club sweeps relative to body
                clubAngle = shotAngle - standAngle + golfer.swingAngle;
            } else if (isDragging) {
                // While aiming, club points toward the ball
                const toBallAngle = Math.atan2(ball.y - gy, ball.x - gx);
                clubAngle = toBallAngle - standAngle;
            } else {
                // Idle ‚Äî club rests at side
                clubAngle = Math.PI / 4;
            }

            // Arms reaching toward club grip
            const gripX = Math.cos(clubAngle) * 10 * s;
            const gripY = Math.sin(clubAngle) * 10 * s;

            ctx.strokeStyle = '#ffcc88';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(-3 * s, -14 * s);
            ctx.lineTo(gripX, handY + gripY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(3 * s, -14 * s);
            ctx.lineTo(gripX, handY + gripY);
            ctx.stroke();

            // Club shaft
            const clubEndX = gripX + Math.cos(clubAngle) * clubLen;
            const clubEndY = handY + gripY + Math.sin(clubAngle) * clubLen;

            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(gripX, handY + gripY);
            ctx.lineTo(clubEndX, clubEndY);
            ctx.stroke();

            // Club head
            const headAngle = clubAngle + Math.PI / 2;
            ctx.strokeStyle = '#A0A0A0';
            ctx.lineWidth = 5 * s;
            ctx.beginPath();
            ctx.moveTo(clubEndX - Math.cos(headAngle) * 5, clubEndY - Math.sin(headAngle) * 5);
            ctx.lineTo(clubEndX + Math.cos(headAngle) * 5, clubEndY + Math.sin(headAngle) * 5);
            ctx.stroke();

            ctx.restore();
        }

        function drawTrail() {
            if (ballTrail.length < 2) return;

            const now = Date.now();
            const TRAIL_DECAY_MS = 3000; // Trail fully fades over 3 seconds

            // Standard dashed trail (driver/iron only) with time decay
            if (selectedClub !== 'putter') {
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                // Draw segments individually so each can fade
                for (let i = 1; i < ballTrail.length; i++) {
                    const age = now - ballTrail[i].t;
                    const fade = Math.max(0, 1 - age / TRAIL_DECAY_MS);
                    if (fade <= 0) continue;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.35 * fade})`;
                    ctx.beginPath();
                    ctx.moveTo(ballTrail[i - 1].x, ballTrail[i - 1].y);
                    ctx.lineTo(ballTrail[i].x, ballTrail[i].y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }

            // Shimmer trail for gold/diamond balls on ground phase
            if (activeBall === 'goldBall' || activeBall === 'diamondBall') {
                const isDiamond = activeBall === 'diamondBall';
                const isPutter = selectedClub === 'putter';
                const minProgress = isPutter ? 0 : 0.80;
                const SHIMMER_DECAY_MS = isDiamond ? 4000 : 3000;

                ctx.save();
                for (let i = 0; i < ballTrail.length; i++) {
                    const pt = ballTrail[i];
                    if (pt.p < minProgress) continue;

                    // Time-based decay
                    const age = now - pt.t;
                    const fade = Math.max(0, 1 - age / SHIMMER_DECAY_MS);
                    if (fade <= 0) continue;

                    // Animated flicker per point
                    const flicker = 0.4 + 0.6 * Math.abs(Math.sin(now * 0.004 + i * 0.7));
                    const alpha = fade * flicker * (isDiamond ? 0.7 : 0.5);

                    if (isDiamond) {
                        ctx.fillStyle = `rgba(200, 230, 255, ${alpha})`;
                    } else {
                        ctx.fillStyle = `rgba(255, 225, 100, ${alpha})`;
                    }

                    // Draw small glisten dot every few points
                    if (i % 3 === 0) {
                        const size = (isDiamond ? 3 : 2.5) * (0.5 + flicker * 0.5) * fade;
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Sparkle stars on some points (diamond gets more)
                    if (i % (isDiamond ? 8 : 14) === 0) {
                        const sparkAlpha = fade * flicker * (isDiamond ? 0.8 : 0.5);
                        ctx.fillStyle = `rgba(255, 255, 255, ${sparkAlpha})`;
                        const s = (isDiamond ? 4 : 3) * flicker * fade;
                        ctx.beginPath();
                        ctx.moveTo(pt.x, pt.y - s);
                        ctx.lineTo(pt.x + s * 0.3, pt.y);
                        ctx.lineTo(pt.x, pt.y + s);
                        ctx.lineTo(pt.x - s * 0.3, pt.y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(pt.x - s, pt.y);
                        ctx.lineTo(pt.x, pt.y + s * 0.3);
                        ctx.lineTo(pt.x + s, pt.y);
                        ctx.lineTo(pt.x, pt.y - s * 0.3);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                ctx.restore();
            }
        }

        // Compute points along the exponential bend curve
        function computeBendCurve(startX, startY, dirAngle, totalDist, totalBendAngle, numSegments) {
            const points = [{ x: startX, y: startY }];
            const k = BEND_K;

            if (Math.abs(totalBendAngle) < 0.001) {
                // Straight line
                for (let i = 1; i <= numSegments; i++) {
                    const t = i / numSegments;
                    points.push({
                        x: startX + Math.cos(dirAngle) * totalDist * t,
                        y: startY + Math.sin(dirAngle) * totalDist * t
                    });
                }
                return points;
            }

            // A normalizes so the integral of A*e^(k*t) from 0 to 1 = totalBendAngle
            const A = totalBendAngle * k / (Math.exp(k) - 1);
            let angle = dirAngle;
            let x = startX, y = startY;
            const stepDist = totalDist / numSegments;

            for (let i = 1; i <= numSegments; i++) {
                const prevT = (i - 1) / numSegments;
                const dt = 1 / numSegments;
                // Incremental angle change: A * e^(k*prevT) * dt
                const dAngle = A * Math.exp(k * prevT) * dt;
                angle += dAngle;
                x += Math.cos(angle) * stepDist;
                y += Math.sin(angle) * stepDist;
                points.push({ x, y });
            }

            return points;
        }

        // ==================== PREDICTOR PATH (left white space) ====================
        const PREDICTOR_X = 10;
        const PREDICTOR_Y = 225;  // Bottom at ~785, right above cigs button
        const PREDICTOR_W = 110;
        const PREDICTOR_H = 560;

        // Fun meter (thin power bar to the right of predictor)
        const FUN_X = PREDICTOR_X + PREDICTOR_W + 6;
        const FUN_Y = PREDICTOR_Y;
        const FUN_W = 14;
        const FUN_H = PREDICTOR_H;

        // Swag meter (next to fun meter)
        const SWAG_X = FUN_X + FUN_W + 4;
        const SWAG_Y = FUN_Y;
        const SWAG_W = 14;
        const SWAG_H = FUN_H;

        function drawFunMeter() {
            ctx.save();

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(FUN_X, FUN_Y, FUN_W, FUN_H);
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.strokeRect(FUN_X, FUN_Y, FUN_W, FUN_H);

            // Power from meter (use frozen value during ball flight)
            const powerPct = ballMoving ? (frozenPower !== null ? frozenPower : 0) : meterPower;

            // Fill from bottom up
            const fillH = FUN_H * powerPct;
            const gradient = ctx.createLinearGradient(FUN_X, FUN_Y + FUN_H, FUN_X, FUN_Y);
            gradient.addColorStop(0, '#cc6633');
            gradient.addColorStop(0.5, '#ff4444');
            gradient.addColorStop(1, '#ff0066');
            ctx.fillStyle = gradient;
            ctx.fillRect(FUN_X, FUN_Y + FUN_H - fillH, FUN_W, fillH);

            // Label "FUN" rotated vertically at top
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 8px sans-serif';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(FUN_X + FUN_W / 2, FUN_Y + FUN_H / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('FUN', 0, 3);
            ctx.restore();



            ctx.restore();
        }

        function getSwagPct() {
            return Math.abs(bendMeter) / 5;
        }

        function drawSwagMeter() {
            ctx.save();

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(SWAG_X, SWAG_Y, SWAG_W, SWAG_H);
            ctx.strokeStyle = 'rgba(0, 255, 200, 0.5)';
            ctx.lineWidth = 1;
            ctx.strokeRect(SWAG_X, SWAG_Y, SWAG_W, SWAG_H);

            // Fill from bottom up (use frozen value during ball flight)
            const swagPct = ballMoving ? (frozenSwag !== null ? frozenSwag : 0) : getSwagPct();
            const fillH = SWAG_H * swagPct;
            const gradient = ctx.createLinearGradient(SWAG_X, SWAG_Y + SWAG_H, SWAG_X, SWAG_Y);
            gradient.addColorStop(0, '#00cc88');
            gradient.addColorStop(0.5, '#00ffcc');
            gradient.addColorStop(1, '#66ffee');
            ctx.fillStyle = gradient;
            ctx.fillRect(SWAG_X, SWAG_Y + SWAG_H - fillH, SWAG_W, fillH);

            // Label "SWAG" rotated vertically
            ctx.fillStyle = '#00ffcc';
            ctx.font = 'bold 7px sans-serif';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(SWAG_X + SWAG_W / 2, SWAG_Y + SWAG_H / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('SWAG', 0, 3);
            ctx.restore();

            ctx.restore();
        }

        function drawBullseye(x, y, radius) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.66, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.33, 0, Math.PI * 2);
            ctx.fill();
        }

        function computePredictorPoints() {
            const pad = 15;
            const availW = PREDICTOR_W - pad * 2;
            const availH = PREDICTOR_H - pad * 2;
            const windowCenterX = PREDICTOR_X + PREDICTOR_W / 2;
            const bottomY = PREDICTOR_Y + PREDICTOR_H - pad;

            // Wobble: -1 (left/wings) to +1 (right/beers)
            const wobbleNorm = bendMeter / 5;

            // Start and end x shift to the wobble side
            const sideOffset = wobbleNorm * (availW / 2);
            const startX = windowCenterX + sideOffset;

            // Curve bows toward the opposite side (toward center)
            const bowAmplitude = Math.abs(wobbleNorm) * (availW / 2);
            const bowSign = wobbleNorm > 0 ? -1 : wobbleNorm < 0 ? 1 : 0;

            // Power determines how high the endpoint goes
            const powerHeight = meterPower * availH;

            // Generate parametric curve points
            const numPoints = 40;
            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const x = startX + bowSign * bowAmplitude * Math.sin(Math.PI * t);
                const y = bottomY - t * powerHeight;
                points.push({ x, y });
            }
            return points;
        }

        function drawPredictorPath() {
            const points = ballMoving ? frozenPredictorPoints : computePredictorPoints();
            if (!points) return;

            // Draw faint predictor background
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(PREDICTOR_X - 2, PREDICTOR_Y - 2, PREDICTOR_W + 4, PREDICTOR_H + 4);

            // Draw ball dot at start (bottom)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(points[0].x, points[0].y, 4, 0, Math.PI * 2);
            ctx.fill();

            // Draw path
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw bullseye at endpoint
            const last = points[points.length - 1];
            drawBullseye(last.x, last.y, 8);

            ctx.restore();
        }

        // ==================== SHOT SUMMARY BOX (above predictor, left or right) ====================
        function drawShotSummary() {
            if (replayingOpponentShot) return;
            if (shotSummaryMessages.length === 0 && displayBeers === 0 && displayCigs === 0) return;

            // Position: left side on holes 1, 4, 18; right side on others
            const leftSideHoles = [1, 4, 18];
            const isLeft = currentHole && leftSideHoles.includes(currentHole.id);
            const BOX_W = PREDICTOR_W;
            const BOX_H = PREDICTOR_Y - 20; // Fill space above predictor
            const BOX_X = isLeft ? PREDICTOR_X : (CANVAS_WIDTH - PREDICTOR_X - BOX_W);
            const BOX_Y = 10;

            ctx.save();
            // Background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(BOX_X, BOX_Y, BOX_W, BOX_H);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 2;
            ctx.strokeRect(BOX_X, BOX_Y, BOX_W, BOX_H);

            // Bold black text messages
            ctx.fillStyle = '#000';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'left';
            const LINE_H = 28;
            shotSummaryMessages.forEach((msg, i) => {
                const y = BOX_Y + 20 + i * LINE_H;
                if (y < BOX_Y + BOX_H - 10) {
                    ctx.fillText(msg, BOX_X + 6, y, BOX_W - 12);
                }
            });

            // Beer/cig count text + icons
            let countY = BOX_Y + 12 + shotSummaryMessages.length * LINE_H;
            if (displayBeers > 0 && countY + 14 < BOX_Y + BOX_H - 4) {
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText('Beers: ' + displayBeers, BOX_X + 6, countY + 14);
                if (beerImg.complete) {
                    ctx.drawImage(beerImg, BOX_X + BOX_W - 28, countY, 22, 22);
                }
                countY += 28;
            }
            if (displayCigs > 0 && countY + 14 < BOX_Y + BOX_H - 4) {
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText('Cigs: ' + displayCigs, BOX_X + 6, countY + 14);
                if (cigImg.complete) {
                    ctx.drawImage(cigImg, BOX_X + BOX_W - 28, countY, 22, 22);
                }
            }

            ctx.restore();
        }

        // ==================== SHOT STATS WINDOW (right side) ====================
        const STATS_SIZE = 180;  // Square box
        const STATS_X = CANVAS_WIDTH - 10 - STATS_SIZE;
        const STATS_Y = 785 - STATS_SIZE;

        // Helper: draw red text with black border
        function drawRedBorderText(text, x, y, fontSize) {
            ctx.font = 'bold ' + fontSize + 'px sans-serif';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.strokeText(text, x, y);
            ctx.fillStyle = '#cc3333';
            ctx.fillText(text, x, y);
        }

        // Frozen flag state for after shot is taken
        let frozenFlagTime = 0;
        let flagFrozen = false;

        function drawFlagPreview() {
            // Show during tee shot setup OR frozen after shot until ball stops
            if (replayingOpponentShot) return;
            if (!isTeeShotActive && !flagFrozen) return;
            if (shotStatsVisible && !isTeeShotActive && !flagFrozen) return;

            ctx.save();
            // Background (same as predictor path)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(STATS_X, STATS_Y, STATS_SIZE, STATS_SIZE);

            // Draw larger flag centered in the box
            const cx = STATS_X + STATS_SIZE / 2;
            const cy = STATS_Y + STATS_SIZE - 20;
            const poleH = 120;

            // Pole
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx, cy - poleH);
            ctx.stroke();

            // Pole ball
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(cx, cy - poleH, 4, 0, Math.PI * 2);
            ctx.fill();

            const t = flagFrozen ? frozenFlagTime : Date.now() * 0.004;

            if (windStrength === 0) {
                // Limp flag
                ctx.fillStyle = 'rgba(220, 60, 60, 0.8)';
                ctx.beginPath();
                ctx.moveTo(cx, cy - poleH + 4);
                ctx.lineTo(cx + 6, cy - poleH + 50);
                ctx.lineTo(cx - 6, cy - poleH + 50);
                ctx.lineTo(cx, cy - poleH + 46);
                ctx.closePath();
                ctx.fill();
            } else {
                const dir = windDirection;
                const flagLen = 40 + windStrength * 30;
                const segments = 10;
                const segW = flagLen / segments;
                const flagH = 32;
                const waveAmp = 3 + windStrength * 5;
                const topY = cy - poleH + 4;

                ctx.fillStyle = 'rgba(220, 60, 60, 0.85)';
                ctx.beginPath();
                ctx.moveTo(cx, topY);
                for (let s = 1; s <= segments; s++) {
                    const fx = cx + dir * s * segW;
                    const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8) * waveAmp;
                    ctx.lineTo(fx, topY + wave);
                }
                for (let s = segments; s >= 0; s--) {
                    const fx = cx + dir * s * segW;
                    const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8 + 1) * waveAmp;
                    ctx.lineTo(fx, topY + flagH + wave);
                }
                ctx.closePath();
                ctx.fill();

                // White stripe
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let s = 0; s <= segments; s++) {
                    const fx = cx + dir * s * segW;
                    const wave = Math.sin(t * (2 + windStrength * 3) + s * 0.8 + 0.5) * waveAmp;
                    if (s === 0) ctx.moveTo(fx, topY + flagH / 2 + wave);
                    else ctx.lineTo(fx, topY + flagH / 2 + wave);
                }
                ctx.stroke();
            }

            // Wind speed text at bottom
            const mph = Math.round(windStrength * 30);
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.fillText(mph + ' mph ' + (windDirection > 0 ? '‚Üí' : '‚Üê'), cx, cy + 2);

            ctx.restore();
        }

        function drawShotStats() {
            // Don't show stats while flag preview is active
            if (isTeeShotActive || flagFrozen) return;
            if (!shotStatsVisible || replayingOpponentShot) return;

            ctx.save();
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(STATS_X, STATS_Y, STATS_SIZE, STATS_SIZE);
            // Red border
            ctx.strokeStyle = '#cc3333';
            ctx.lineWidth = 3;
            ctx.strokeRect(STATS_X, STATS_Y, STATS_SIZE, STATS_SIZE);

            // Small X close indicator (top-right corner)
            ctx.font = 'bold 14px sans-serif';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.textAlign = 'right';
            ctx.fillText('x', STATS_X + STATS_SIZE - 6, STATS_Y + 14);

            ctx.textAlign = 'left';
            const x = STATS_X + 10;
            let y = STATS_Y + 28;
            const lineH = 32;

            // Club name
            drawRedBorderText(frozenStatClub.toUpperCase(), x, y, 20);
            y += lineH;

            // Ball speed
            drawRedBorderText(Math.round(frozenStatSpeed) + ' mph', x, y, 22);
            y += lineH;

            // Distance (live during flight)
            const feetPerPx = holeStartDistance > 0 ? PAR4_HOLE_FT / holeStartDistance : 2.4;
            const dist = ballMoving ? shotCumulativeDistance * feetPerPx : frozenStatDistance;
            drawRedBorderText(Math.round(dist) + ' ft', x, y, 22);
            y += lineH;

            // Air time
            drawRedBorderText(frozenStatAirTime.toFixed(1) + 's air', x, y, 22);
            y += lineH;

            // Swag %
            ctx.font = 'bold 22px sans-serif';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.strokeText(frozenStatSwag + '% swag', x, y);
            ctx.fillStyle = '#00ffdc';
            ctx.fillText(frozenStatSwag + '% swag', x, y);

            ctx.restore();
        }

        function finalizeShotSummary() {
            const feetPerPx = holeStartDistance > 0 ? PAR4_HOLE_FT / holeStartDistance : 2.4;
            frozenStatDistance = shotCumulativeDistance * feetPerPx;
            flagFrozen = false; // Show stats now instead of flag
        }

        // ==================== MP CHAT BOX (bottom-right of canvas) ====================
        function drawMpChat() {
            if (!isMultiplayer) return;
            // Expire messages older than 10 seconds
            const now = Date.now();
            mpChatMessages = mpChatMessages.filter(m => now - m.time < 10000);
            if (mpChatMessages.length === 0) return;

            const CHAT_SIZE = 170;  // Square box
            const LINE_H = 16;
            const CHAT_X = CANVAS_WIDTH - 10 - CHAT_SIZE;
            const CHAT_Y = CANVAS_HEIGHT - 10 - CHAT_SIZE;

            ctx.save();
            // Background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            ctx.fillRect(CHAT_X, CHAT_Y, CHAT_SIZE, CHAT_SIZE);
            // Red border
            ctx.strokeStyle = 'rgba(200, 50, 50, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(CHAT_X, CHAT_Y, CHAT_SIZE, CHAT_SIZE);

            // Messages (draw from bottom up so newest are at bottom)
            ctx.fillStyle = '#000';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            mpChatMessages.forEach((msg, i) => {
                const y = CHAT_Y + 14 + i * LINE_H;
                if (y < CHAT_Y + CHAT_SIZE - 4) {
                    ctx.fillText(msg.text, CHAT_X + 6, y, CHAT_SIZE - 12);
                }
            });
            ctx.restore();
        }

        function drawBendPreview() {
            if (!isDragging) return;

            const dx = dragStartX - dragEndX;
            const dy = dragStartY - dragEndY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= 0) return;

            // Putter uses drag-based power, others use meter
            let power;
            if (selectedClub === 'putter') {
                const maxVisibleDrag = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / (2 * cameraZoom);
                const targetDrag = maxVisibleDrag * 0.6;
                const putterDivisor = (targetDrag * cameraZoom) / (MAX_POWER * 0.67);
                power = Math.min((dist * cameraZoom) / putterDivisor, MAX_POWER);
            } else {
                power = MAX_POWER * meterPower;
            }
            let speed = power * 0.05625;
            const clubMaxDist = getClubMaxDistance();
            const clubMaxSpeed = clubMaxDist * (1 - FRICTION);
            speed = Math.min(speed, clubMaxSpeed);
            const actualTravelDist = speed / (1 - FRICTION);

            // Preview shows half of actual travel distance
            const previewDist = actualTravelDist * 0.2;

            const dirAngle = Math.atan2(dy / dist, dx / dist);

            // Straight line preview (no bend)
            const endX = ball.x + Math.cos(dirAngle) * previewDist;
            const endY = ball.y + Math.sin(dirAngle) * previewDist;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(ball.x, ball.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ==================== CAMERA ====================
        function updateCamera() {
            const maxZoom = CLUB_ZOOM[selectedClub];

            // UI panel width (predictor + fun + swag meters + padding)
            const UI_PANEL_W = 160;

            if (maxZoom > 1.0 && currentHole && currentHole.holePos) {
                const hx = currentHole.holePos.x;
                const hy = currentHole.holePos.y;

                // Visible area: right portion of canvas past the UI panel
                // Screen coords: UI panel covers [0, UI_PANEL_W], game visible in [UI_PANEL_W, CANVAS_WIDTH]
                // Visible center in screen space:
                const visCenterScreen = (UI_PANEL_W + CANVAS_WIDTH) / 2;

                // Calculate zoom to fit both ball and hole in the visible area
                const dx = Math.abs(ball.x - hx);
                const dy = Math.abs(ball.y - hy);
                const pad = 60;
                const usableW = CANVAS_WIDTH - UI_PANEL_W;
                const fitZoomX = (dx + pad * 2) > 0 ? usableW / (dx + pad * 2) : maxZoom;
                const fitZoomY = (dy + pad * 2) > 0 ? CANVAS_HEIGHT / (dy + pad * 2) : maxZoom;
                const fitZoom = Math.min(fitZoomX, fitZoomY);

                cameraTargetZoom = Math.max(1.0, Math.min(maxZoom, fitZoom));

                // Center between ball and hole in game coords
                const midX = (ball.x + hx) / 2;
                const midY = (ball.y + hy) / 2;

                // Offset camera so the midpoint appears at the visible center (not canvas center)
                // Screen position of a game point: screenX = (gx - cameraX) * zoom + CANVAS_WIDTH/2
                // We want midX to appear at visCenterScreen:
                // visCenterScreen = (midX - cameraX) * zoom + CANVAS_WIDTH/2
                // cameraX = midX - (visCenterScreen - CANVAS_WIDTH/2) / zoom
                const offsetX = (visCenterScreen - CANVAS_WIDTH / 2) / cameraTargetZoom;
                cameraTargetX = midX - offsetX;
                cameraTargetY = midY;
            } else {
                cameraTargetZoom = 1.0;
                cameraTargetX = CANVAS_WIDTH / 2;
                cameraTargetY = CANVAS_HEIGHT / 2;
            }

            cameraZoom += (cameraTargetZoom - cameraZoom) * CAMERA_LERP;
            cameraX += (cameraTargetX - cameraX) * CAMERA_LERP;
            cameraY += (cameraTargetY - cameraY) * CAMERA_LERP;

            if (Math.abs(cameraZoom - cameraTargetZoom) < 0.001) cameraZoom = cameraTargetZoom;
            if (Math.abs(cameraX - cameraTargetX) < 0.1) cameraX = cameraTargetX;
            if (Math.abs(cameraY - cameraTargetY) < 0.1) cameraY = cameraTargetY;

            // Clamp so viewport stays within course bounds
            const halfVisW = CANVAS_WIDTH / (2 * cameraZoom);
            const halfVisH = CANVAS_HEIGHT / (2 * cameraZoom);
            cameraX = Math.max(halfVisW, Math.min(CANVAS_WIDTH - halfVisW, cameraX));
            cameraY = Math.max(halfVisH, Math.min(CANVAS_HEIGHT - halfVisH, cameraY));
        }

        function applyCameraTransform() {
            ctx.save();
            ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-cameraX, -cameraY);
        }

        function restoreCameraTransform() {
            ctx.restore();
        }

        // ==================== GAME LOOP ====================
        function gameLoop() {
            if (!gameStarted) return;

            // Update camera zoom and position (smooth lerp)
            updateCamera();

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Increase saturation and contrast with swag level
            const swag = getSwagPct();
            const sat = 1 + swag * 1.5;   // 1.0 ‚Üí 2.5
            const con = 1 + swag * 0.5;   // 1.0 ‚Üí 1.5
            canvas.style.filter = swag > 0 ? `saturate(${sat}) contrast(${con})` : '';

            // Update game logic (no drawing)
            updateBall();
            updateGolfer();
            updateClouds();
            updateFireworks();

            // === ZOOMED WORLD DRAWING ===
            applyCameraTransform();
            drawCourse();
            drawHole();
            drawClouds();
            drawTrail();
            drawBall();
            if (isMultiplayer) drawAllPlayerBalls();
            drawFireworks();
            drawGolfer();
            drawBendPreview();
            restoreCameraTransform();

            // === SCREEN-SPACE UI (not zoomed) ===
            drawPredictorPath();
            drawFunMeter();
            drawSwagMeter();
            drawShotSummary();
            drawFlagPreview();
            drawShotStats();
            drawMpChat();

            // Border area: predictor + fun meter + swag meter
            const borderX = PREDICTOR_X - 2;
            const borderY = PREDICTOR_Y - 2;
            const borderW = (SWAG_X + SWAG_W) - PREDICTOR_X + 4;
            const borderH = PREDICTOR_H + 4;

            // Pulsing power border (red)
            if (meterPower > 0) {
                const pw = meterPower;
                const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.003);
                const alpha = pw * 0.8 * pulse;
                const width = 1 + pw * 4;
                ctx.save();
                ctx.strokeStyle = `rgba(255, 30, 30, ${alpha})`;
                ctx.lineWidth = width;
                ctx.strokeRect(borderX - width / 2, borderY - width / 2, borderW + width, borderH + width);
                ctx.restore();
            }

            // Pulsing swag border (cyan)
            const swagPct = getSwagPct();
            if (swagPct > 0) {
                const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.003 + 1.5);
                const alpha = swagPct * 0.8 * pulse;
                const width = 1 + swagPct * 4;
                const offset = meterPower > 0 ? (1 + meterPower * 4) + 2 : 0;
                ctx.save();
                ctx.strokeStyle = `rgba(0, 255, 220, ${alpha})`;
                ctx.lineWidth = width;
                ctx.strokeRect(borderX - offset - width / 2, borderY - offset - width / 2, borderW + offset * 2 + width, borderH + offset * 2 + width);
                ctx.restore();
            }

            // Spin widget (shown during ball flight with wobble)
            if (ballMoving && shotBendActive && selectedClub !== 'putter' && !replayingOpponentShot) {
                drawSpinWidget();
            }

            requestAnimationFrame(gameLoop);
        }

        function drawSpinWidget() {
            const cx = CANVAS_WIDTH / 2;
            const cy = CANVAS_HEIGHT;
            const r = 90;

            ctx.save();

            // Semicircle background
            ctx.beginPath();
            ctx.arc(cx, cy, r, Math.PI, 0);
            ctx.closePath();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Ball icon in center
            ctx.beginPath();
            ctx.arc(cx, cy - r * 0.35, 20, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Left arrow
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.moveTo(cx - 50, cy - r * 0.35);
            ctx.lineTo(cx - 30, cy - r * 0.35 - 14);
            ctx.lineTo(cx - 30, cy - r * 0.35 + 14);
            ctx.closePath();
            ctx.fill();

            // Right arrow
            ctx.beginPath();
            ctx.moveTo(cx + 50, cy - r * 0.35);
            ctx.lineTo(cx + 30, cy - r * 0.35 - 14);
            ctx.lineTo(cx + 30, cy - r * 0.35 + 14);
            ctx.closePath();
            ctx.fill();

            // Spin label
            ctx.fillStyle = isSpinDragging ? 'rgba(0, 255, 220, 0.9)' : 'rgba(255, 255, 255, 0.5)';
            ctx.font = "italic 18px 'Playfair Display', serif";
            ctx.textAlign = 'center';
            ctx.fillText('SPIN', cx, cy - 4);

            ctx.restore();
        }

        // ==================== FIREBASE SCORING & LEADERBOARD ====================
        const leaderboardRef = db.ref('golf_leaderboard');

        function saveScore() {
            const playerId = localStorage.getItem('golfPlayerId') || generateId();
            localStorage.setItem('golfPlayerId', playerId);

            db.ref('golf_scores/' + playerId + '/hole' + currentHole.id).set({
                strokes: strokes,
                bendMeter: bendMeter,
                timestamp: Date.now(),
                holeName: currentHole.name
            });
        }

        function generateId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function addLeaderboardEntry(name, scoreToPar) {
            const entry = { name: name, scoreToPar: scoreToPar, ts: Date.now() };
            leaderboardRef.push(entry);
            return entry;
        }

        function renderLeaderboard(currentEntry) {
            leaderboardRef.once('value', (snapshot) => {
                const entries = [];
                snapshot.forEach((child) => {
                    entries.push(child.val());
                });
                // Sort by score to par ascending (lower is better)
                entries.sort((a, b) => a.scoreToPar - b.scoreToPar);
                const top10 = entries.slice(0, 10);

                const tbody = document.getElementById('leaderboardBody');
                tbody.innerHTML = '';

                top10.forEach((e, i) => {
                    const tr = document.createElement('tr');
                    if (currentEntry && e.ts === currentEntry.ts) tr.className = 'current-entry';
                    const parStr = e.scoreToPar === 0 ? 'E' : (e.scoreToPar > 0 ? '+' + e.scoreToPar : '' + e.scoreToPar);
                    const td1 = document.createElement('td'); td1.textContent = i + 1;
                    const td2 = document.createElement('td'); td2.textContent = e.name;
                    const td3 = document.createElement('td'); td3.textContent = parStr;
                    tr.append(td1, td2, td3);
                    tbody.appendChild(tr);
                });

                document.getElementById('leaderboardSection').style.display = 'block';
            }, (error) => {
                console.error('Leaderboard fetch failed:', error);
            });
        }

        // ==================== MULTIPLAYER SYSTEM ====================

        function showMpLobbySection(sectionId) {
            ['mpNameEntry', 'mpLobbyBrowser', 'mpLobbyCreate', 'mpLobbyRoom'].forEach(id => {
                document.getElementById(id).style.display = (id === sectionId) ? 'block' : 'none';
            });
        }

        function getMpPlayerNameBySlot(slot) {
            for (const [, p] of Object.entries(lobbyPlayers)) {
                if (p.slot === slot) return p.name || 'Player';
            }
            return 'Player';
        }

        // Lobby name entry
        document.getElementById('mpNameConfirmBtn').addEventListener('click', mpSubmitName);
        document.getElementById('mpNameInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') mpSubmitName(); });

        function mpSubmitName() {
            const name = document.getElementById('mpNameInput').value.trim().toUpperCase();
            if (!name) return;
            playerName = name;
            loadPlayerData(name);
            // Update main menu UI too
            document.getElementById('mainNameEntry').style.display = 'none';
            document.getElementById('playerInfo').style.display = 'block';
            updatePlayerUI();
            showMpLobbySection('mpLobbyBrowser');
            showMpLobbyBrowser();
        }

        document.getElementById('mpNameBackBtn').addEventListener('click', () => {
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('modeSelect').style.display = 'flex';
            document.getElementById('playModeSelect').style.display = 'none';
            if (playerName) {
                document.getElementById('playerInfo').style.display = 'block';
            } else {
                document.getElementById('mainNameEntry').style.display = 'block';
            }
        });

        // Lobby browser
        let lobbyBrowserRef = null;

        function showMpLobbyBrowser() {
            if (lobbyBrowserRef) lobbyBrowserRef.off('value');
            lobbyBrowserRef = db.ref('golf_lobbies');
            lobbyBrowserRef.on('value', (snapshot) => {
                const list = document.getElementById('mpLobbyList');
                list.innerHTML = '';
                let hasLobbies = false;
                snapshot.forEach((child) => {
                    const lobby = child.val();
                    if (lobby.status !== 'waiting' && lobby.status !== 'playing') return;
                    if (lobby.playerCount >= 4) return;
                    hasLobbies = true;
                    const item = document.createElement('div');
                    item.className = 'mp-lobby-item';
                    item.innerHTML = `
                        <span style="font-size:14px;">${lobby.name || 'Course'}</span>
                        <span style="font-size:12px; color:#ccc;">${lobby.playerCount || 1}/4</span>
                    `;
                    const joinBtn = document.createElement('button');
                    joinBtn.className = 'mode-btn mode-btn-play';
                    joinBtn.style.cssText = 'font-size:12px; padding:4px 12px;';
                    joinBtn.textContent = 'JOIN';
                    joinBtn.addEventListener('click', () => joinMpLobby(child.key));
                    item.appendChild(joinBtn);
                    list.appendChild(item);
                });
                document.getElementById('mpNoLobbiesMsg').style.display = hasLobbies ? 'none' : 'block';
            });
        }

        document.getElementById('mpCreateLobbyBtn').addEventListener('click', () => {
            showMpLobbySection('mpLobbyCreate');
            document.getElementById('mpLobbyNameInput').value = '';
            document.getElementById('mpLobbyNameInput').focus();
        });

        document.getElementById('mpBrowserBackBtn').addEventListener('click', () => {
            if (lobbyBrowserRef) { lobbyBrowserRef.off('value'); lobbyBrowserRef = null; }
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('modeSelect').style.display = 'flex';
            document.getElementById('playModeSelect').style.display = 'none';
            if (playerName) {
                document.getElementById('playerInfo').style.display = 'block';
            } else {
                document.getElementById('mainNameEntry').style.display = 'block';
            }
        });

        // Create lobby
        document.getElementById('mpCreateConfirmBtn').addEventListener('click', createMpLobby);
        document.getElementById('mpLobbyNameInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') createMpLobby(); });

        function createMpLobby() {
            const name = document.getElementById('mpLobbyNameInput').value.trim();
            if (!name) return;
            if (lobbyBrowserRef) { lobbyBrowserRef.off('value'); lobbyBrowserRef = null; }

            myPlayerId = db.ref().push().key;
            mySlot = 'p1';
            const lobbyRef = db.ref('golf_lobbies').push();
            currentLobby = lobbyRef;
            currentLobbyId = lobbyRef.key;

            lobbyRef.set({
                name: name,
                status: 'waiting',
                created: firebase.database.ServerValue.TIMESTAMP,
                playerCount: 1,
                players: {
                    [myPlayerId]: { name: playerName, connected: true, slot: 'p1' }
                }
            }).then(() => {
                lobbyRef.child('players/' + myPlayerId + '/connected').onDisconnect().cancel();
                lobbyRef.child('players/' + myPlayerId + '/connected').onDisconnect().set(false);
                lobbyRef.child('status').onDisconnect().cancel();
                lobbyRef.child('status').onDisconnect().set('closed');
                showMpLobbyRoom();
            });
        }

        document.getElementById('mpCreateBackBtn').addEventListener('click', () => {
            showMpLobbySection('mpLobbyBrowser');
            showMpLobbyBrowser();
        });

        // Join lobby
        function joinMpLobby(lobbyId) {
            if (lobbyBrowserRef) { lobbyBrowserRef.off('value'); lobbyBrowserRef = null; }
            const lobbyRef = db.ref('golf_lobbies/' + lobbyId);

            lobbyRef.once('value', (snapshot) => {
                const lobby = snapshot.val();
                if (!lobby || lobby.playerCount >= 4 || lobby.status !== 'waiting') return;

                const existingSlots = [];
                if (lobby.players) {
                    Object.values(lobby.players).forEach(p => existingSlots.push(p.slot));
                }
                const allSlots = ['p1', 'p2', 'p3', 'p4'];
                const nextSlot = allSlots.find(s => !existingSlots.includes(s));
                if (!nextSlot) return;

                myPlayerId = db.ref().push().key;
                mySlot = nextSlot;
                currentLobby = lobbyRef;
                currentLobbyId = lobbyId;

                const updates = {};
                updates['players/' + myPlayerId] = { name: playerName, connected: true, slot: nextSlot };
                updates['playerCount'] = (lobby.playerCount || 1) + 1;
                lobbyRef.update(updates).then(() => {
                    lobbyRef.child('players/' + myPlayerId + '/connected').onDisconnect().cancel();
                    lobbyRef.child('players/' + myPlayerId + '/connected').onDisconnect().set(false);
                    showMpLobbyRoom();
                });
            });
        }

        // Lobby room
        function showMpLobbyRoom() {
            showMpLobbySection('mpLobbyRoom');

            const playersRef = currentLobby.child('players');
            const statusRef = currentLobby.child('status');

            const playersListener = playersRef.on('value', (snap) => {
                if (!snap.exists()) return;
                lobbyPlayers = {};
                snap.forEach((child) => {
                    lobbyPlayers[child.key] = child.val();
                });
                renderMpLobbyPlayers();

                // Auto-start when 2+ connected
                const connected = Object.values(lobbyPlayers).filter(p => p.connected);
                if (connected.length >= 2 && mySlot === 'p1') {
                    initiateMpGame();
                }
            });
            lobbyRoomListeners.push({ ref: playersRef, event: 'value' });

            const statusListener = statusRef.on('value', (snap) => {
                const status = snap.val();
                if (status === 'playing') {
                    startMultiplayerGame();
                } else if (status === 'closed' && mySlot !== 'p1') {
                    showMpLobbyClosed();
                }
            });
            lobbyRoomListeners.push({ ref: statusRef, event: 'value' });

            // Set lobby name
            currentLobby.child('name').once('value', (snap) => {
                document.getElementById('mpLobbyRoomName').textContent = snap.val() || 'Course';
            });
        }

        function renderMpLobbyPlayers() {
            const list = document.getElementById('mpLobbyPlayerList');
            list.innerHTML = '';
            const players = Object.values(lobbyPlayers).sort((a, b) => a.slot.localeCompare(b.slot));
            players.forEach(p => {
                if (!p.connected) return;
                const div = document.createElement('div');
                div.className = 'mp-lobby-player';
                const dot = document.createElement('span');
                dot.className = 'mp-slot-dot';
                dot.style.background = SLOT_COLORS[p.slot];
                div.appendChild(dot);
                div.appendChild(document.createTextNode(' ' + p.name));
                list.appendChild(div);
            });
            const count = players.filter(p => p.connected).length;
            document.getElementById('mpLobbyPlayerCount').textContent = `${count}/4 players`;
            document.getElementById('mpWaitingMsg').style.display = count < 2 ? 'block' : 'none';
        }

        document.getElementById('mpLeaveLobbyBtn').addEventListener('click', leaveMpLobby);

        function leaveMpLobby() {
            cleanupMpLobby();
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('modeSelect').style.display = 'flex';
            if (playerName) {
                document.getElementById('playerInfo').style.display = 'block';
            } else {
                document.getElementById('mainNameEntry').style.display = 'block';
            }
        }

        function showMpLobbyClosed() {
            cleanupMpLobby();
            cleanupMpGame();
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('mpLobbyClosed').style.display = 'flex';
        }

        document.getElementById('mpLobbyClosedBtn').addEventListener('click', () => {
            document.getElementById('mpLobbyClosed').style.display = 'none';
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('modeSelect').style.display = 'flex';
            if (playerName) {
                document.getElementById('playerInfo').style.display = 'block';
            } else {
                document.getElementById('mainNameEntry').style.display = 'block';
            }
        });

        // Game initialization (host only)
        function initiateMpGame() {
            const activePlayers = Object.values(lobbyPlayers)
                .filter(p => p.connected)
                .sort((a, b) => a.slot.localeCompare(b.slot))
                .map(p => p.slot);

            if (activePlayers.length < 2) return;

            const playerStates = {};
            const firstShotsDone = {};
            const scorecard = {};
            activePlayers.forEach(slot => {
                playerStates[slot] = {
                    ballX: 0, ballY: 0, strokes: 0,
                    holedOut: false, activeBall: 'default', selectedClub: 'driver'
                };
                firstShotsDone[slot] = false;
                scorecard[slot] = [];
            });

            currentLobby.update({
                status: 'playing',
                game: {
                    currentHole: 0,
                    turnOrder: activePlayers,
                    currentTurnIndex: 0,
                    turn: activePlayers[0],
                    phase: 'firstShots',
                    firstShotsDone: firstShotsDone,
                    playerStates: playerStates,
                    scorecard: scorecard,
                    wind: {
                        direction: Math.random() < 0.5 ? -1 : 1,
                        strength: 0.2 + Math.random() * 0.8
                    }
                }
            });
        }

        // Start multiplayer game (all players)
        function startMultiplayerGame() {
            // Cleanup lobby room listeners
            for (const l of lobbyRoomListeners) { l.ref.off(l.event); }
            lobbyRoomListeners = [];

            isMultiplayer = true;
            gameMode = 'play';

            currentLobby.child('game').once('value', (snap) => {
                const game = snap.val();
                if (!game || !game.turnOrder) return;

                turnOrder = game.turnOrder || [];
                currentTurnIndex = game.currentTurnIndex || 0;
                isMyTurn = (game.turn === mySlot);
                mpPhase = game.phase || 'firstShots';
                mpFirstShotsDone = game.firstShotsDone || {};
                mpPlayerStates = game.playerStates || {};
                mpCurrentHoleIndex = game.currentHole || 0;
                mpScorecard = game.scorecard || {};
                allPlayerBalls = {};

                // Load each player's activeBall from their bank
                turnOrder.forEach(slot => {
                    const pName = getMpPlayerNameBySlot(slot);
                    bankRef.child(pName).once('value', (bankSnap) => {
                        const data = bankSnap.val() || {};
                        if (mpPlayerStates[slot]) {
                            mpPlayerStates[slot].activeBall = data.activeBall || 'default';
                            currentLobby.child('game/playerStates/' + slot + '/activeBall').set(data.activeBall || 'default');
                        }
                    });
                });

                document.getElementById('lobbyScreen').style.display = 'none';
                document.getElementById('startScreen').classList.add('hidden');
                document.getElementById('gameScreen').classList.remove('hidden');
                document.getElementById('mpHUD').style.display = 'block';

                setupMpListeners();
                updateMpTurnIndicator();
                updateMpPlayerChips();
                toggleMpControls();

                gameStarted = true;
                const mpDiff = totalStrokes - totalPar;
                const mpFocus = Math.max(0, Math.min(100, 50 - mpDiff * 10));
                const mpFun = Math.min(100, getSwagPct() * 100);
                sendToDJ({ type: 'setGameMode', enabled: gameMusicMode, focus: mpFocus, fun: mpFun });
                startHole(mpCurrentHoleIndex);
            });
        }

        // Firebase listeners
        function setupMpListeners() {
            const turnRef = currentLobby.child('game/turn');
            turnRef.on('value', (snap) => {
                if (!snap.exists()) return;
                const turnSlot = snap.val();
                isMyTurn = (turnSlot === mySlot);
                updateMpTurnIndicator();
                updateMpPlayerChips();
                toggleMpControls();
            });
            mpListeners.push({ ref: turnRef, event: 'value' });

            const shotRef = currentLobby.child('game/shot');
            shotRef.on('value', (snap) => {
                if (!snap.exists()) return;
                const shotData = snap.val();
                if (shotData.player && shotData.player !== mySlot && shotData.timestamp) {
                    replayMpShot(shotData);
                }
            });
            mpListeners.push({ ref: shotRef, event: 'value' });

            const statesRef = currentLobby.child('game/playerStates');
            statesRef.on('value', (snap) => {
                if (snap.exists()) {
                    mpPlayerStates = snap.val();
                    updateMpPlayerChips();
                }
            });
            mpListeners.push({ ref: statesRef, event: 'value' });

            const ballsRef = currentLobby.child('game/balls');
            ballsRef.on('value', (snap) => {
                if (!snap.exists()) return;
                const newBalls = snap.val();
                // Detect opponent holing out ‚Äî spawn fireworks
                for (const slot of turnOrder) {
                    if (slot === mySlot) continue;
                    const prev = allPlayerBalls[slot];
                    const curr = newBalls[slot];
                    if (curr && curr.holedOut && (!prev || !prev.holedOut)) {
                        const opStrokes = (mpPlayerStates[slot] || {}).strokes || 0;
                        const underPar = Math.max(0, currentHole.par - opStrokes);
                        spawnHoleFireworks(currentHole.holePos.x, currentHole.holePos.y, underPar);
                    }
                }
                allPlayerBalls = newBalls;
            });
            mpListeners.push({ ref: ballsRef, event: 'value' });

            const phaseRef = currentLobby.child('game/phase');
            phaseRef.on('value', (snap) => {
                if (snap.exists()) mpPhase = snap.val();
            });
            mpListeners.push({ ref: phaseRef, event: 'value' });

            const windRef = currentLobby.child('game/wind');
            windRef.on('value', (snap) => {
                if (!snap.exists()) return;
                const w = snap.val();
                windDirection = w.direction || 1;
                windStrength = w.strength || 0;
                initClouds();
                updateWindIndicator();
            });
            mpListeners.push({ ref: windRef, event: 'value' });

            const firstRef = currentLobby.child('game/firstShotsDone');
            firstRef.on('value', (snap) => {
                if (snap.exists()) mpFirstShotsDone = snap.val();
            });
            mpListeners.push({ ref: firstRef, event: 'value' });

            const holeRef = currentLobby.child('game/currentHole');
            holeRef.on('value', (snap) => {
                if (!snap.exists()) return;
                const newHole = snap.val();
                if (newHole !== mpCurrentHoleIndex && gameStarted) {
                    mpCurrentHoleIndex = newHole;
                    // Reset local state for new hole
                    allPlayerBalls = {};
                    startHole(mpCurrentHoleIndex);
                    updateMpTurnIndicator();
                    toggleMpControls();
                }
            });
            mpListeners.push({ ref: holeRef, event: 'value' });

            const scorecardRef = currentLobby.child('game/scorecard');
            scorecardRef.on('value', (snap) => {
                if (snap.exists()) mpScorecard = snap.val();
            });
            mpListeners.push({ ref: scorecardRef, event: 'value' });

            let lastHoleComplete = 0;
            const holeCompleteRef = currentLobby.child('game/holeComplete');
            holeCompleteRef.on('value', (snap) => {
                if (!snap.exists()) return;
                const ts = snap.val();
                if (ts > lastHoleComplete) {
                    lastHoleComplete = ts;
                    // Brief delay to let scorecard data sync first
                    setTimeout(() => showMpScorecard(), 600);
                }
            });
            mpListeners.push({ ref: holeCompleteRef, event: 'value' });

            const reactionRef = currentLobby.child('game/reaction');
            let lastReactionTimestamp = 0;
            reactionRef.on('value', (snap) => {
                if (!snap.exists()) return;
                const r = snap.val();
                if (!r.from || !r.text || r.timestamp <= lastReactionTimestamp) return;
                lastReactionTimestamp = r.timestamp;
                const name = getMpPlayerNameBySlot(r.from);
                // Random position near center of visible area
                const cx = cameraX + (Math.random() - 0.5) * (CANVAS_WIDTH / cameraZoom) * 0.4;
                const cy = cameraY + (Math.random() - 0.5) * (CANVAS_HEIGHT / cameraZoom) * 0.3;
                showPowerupFeedback(`${name}: ${r.text}`, cx, cy, 240, 'mp-reaction');
            });
            mpListeners.push({ ref: reactionRef, event: 'value' });

            const playersRef = currentLobby.child('players');
            playersRef.on('value', (snap) => {
                if (!snap.exists()) return;
                lobbyPlayers = {};
                snap.forEach((child) => { lobbyPlayers[child.key] = child.val(); });
                handleMpPlayerDisconnects();
            });
            mpListeners.push({ ref: playersRef, event: 'value' });

            const statusRef = currentLobby.child('status');
            statusRef.on('value', (snap) => {
                if (snap.val() === 'closed' && mySlot !== 'p1') {
                    showMpLobbyClosed();
                }
            });
            mpListeners.push({ ref: statusRef, event: 'value' });
        }

        // HUD updates
        function updateMpTurnIndicator() {
            const indicator = document.getElementById('mpTurnIndicator');
            if (!indicator) return;
            if (isMyTurn) {
                indicator.textContent = 'YOUR TURN';
                indicator.style.borderColor = '#0fb816';
                indicator.style.color = '#0fb816';
            } else {
                const currentTurnSlot = turnOrder[currentTurnIndex] || turnOrder[0];
                const name = getMpPlayerNameBySlot(currentTurnSlot);
                indicator.textContent = name + "'s TURN";
                indicator.style.borderColor = SLOT_COLORS[currentTurnSlot] || '#FFD700';
                indicator.style.color = SLOT_COLORS[currentTurnSlot] || '#FFD700';
            }
        }

        function updateMpPlayerChips() {
            const container = document.getElementById('mpPlayerChips');
            if (!container) return;
            container.innerHTML = '';
            turnOrder.forEach(slot => {
                const state = mpPlayerStates[slot] || {};
                const name = getMpPlayerNameBySlot(slot);
                const chip = document.createElement('span');
                chip.className = 'mp-player-chip';
                if (isMyTurn && slot === mySlot || !isMyTurn && turnOrder[currentTurnIndex] === slot) {
                    chip.classList.add('active');
                }
                if (state.holedOut) chip.classList.add('holed-out');
                chip.style.borderColor = SLOT_COLORS[slot];
                chip.innerHTML = `<span style="color:${SLOT_COLORS[slot]}">‚óè</span> ${name} (${state.strokes || 0})`;
                container.appendChild(chip);
            });
        }

        function toggleMpControls() {
            if (!isMultiplayer) return;
            const beerBtn = document.getElementById('beerBtn');
            const wingBtn = document.getElementById('wingBtn');
            const clubBtn = document.getElementById('clubBtn');
            const reactionBar = document.getElementById('mpReactionBar');

            if (isMyTurn) {
                if (beerBtn) beerBtn.style.display = 'block';
                if (wingBtn) wingBtn.style.display = 'block';
                if (clubBtn) clubBtn.style.display = 'block';
                if (reactionBar) reactionBar.style.display = 'none';
            } else {
                if (beerBtn) beerBtn.style.display = 'none';
                if (wingBtn) wingBtn.style.display = 'none';
                if (clubBtn) clubBtn.style.display = 'none';
                if (reactionBar) reactionBar.style.display = 'flex';
            }
        }

        // Reaction buttons
        document.querySelectorAll('.mp-reaction-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!currentLobby) return;
                currentLobby.child('game/reaction').set({
                    text: btn.dataset.reaction, from: mySlot, timestamp: Date.now()
                });
            });
        });

        // Shot replay
        function replayMpShot(shotData) {
            if (replayingOpponentShot) return; // reject while already replaying
            // Save my ball state before replaying opponent
            myBallSaved = {
                x: ball.x, y: ball.y, activeBall: activeBall,
                selectedClub: selectedClub, strokes: strokes
            };
            replayingOpponentShot = true;
            replayingSlot = shotData.player;

            // Position ball at their shot origin
            ball.x = shotData.ballX || ball.x;
            ball.y = shotData.ballY || ball.y;

            // Apply their shot velocity
            const speed = shotData.speed || 0;
            ball.vx = (shotData.dirX || 0) * speed;
            ball.vy = (shotData.dirY || 0) * speed;

            // Set up bend
            shotTotalBendAngle = shotData.bendAngle || 0;
            shotExpectedDistance = speed / (1 - FRICTION);
            shotCumulativeDistance = 0;
            shotBendActive = Math.abs(shotTotalBendAngle) > 0.001;
            shotPrevT = 0;

            // Show their ball cosmetic and club zoom
            activeBall = shotData.activeBall || 'default';
            selectedClub = shotData.club || 'driver';
            cameraTargetZoom = CLUB_ZOOM[selectedClub];

            ballMoving = true;
            ballTrail = [];
            strokes = (mpPlayerStates[shotData.player] || {}).strokes || 0;

            // Freeze predictor
            frozenPredictorPoints = null;
            frozenPower = null;
            frozenSwag = null;
        }

        // Shot completion in multiplayer
        function onMpShotComplete() {
            if (!isMultiplayer || !currentLobby || !isMyTurn) return;

            // Check if holed
            const hx = currentHole.holePos.x;
            const hy = currentHole.holePos.y;
            const dist = Math.sqrt((ball.x - hx) ** 2 + (ball.y - hy) ** 2);
            const holedOut = dist < 19; // holeRadius

            // Sync ball position
            currentLobby.child('game/balls/' + mySlot).set({
                x: ball.x, y: ball.y, holedOut: holedOut
            });

            // Update my state
            const stateUpdate = {
                ballX: ball.x, ballY: ball.y,
                strokes: strokes,
                selectedClub: selectedClub,
                activeBall: activeBall,
                holedOut: holedOut
            };
            currentLobby.child('game/playerStates/' + mySlot).update(stateUpdate);

            // Award coins if holed out under par
            if (holedOut && playerName) {
                const diff = strokes - currentHole.par;
                if (diff < 0) {
                    const earned = Math.abs(diff);
                    playerCoins += earned;
                    savePlayerData();
                    document.getElementById('coinBalanceValue').textContent = playerCoins;
                }
            }

            if (mpPhase === 'firstShots') {
                currentLobby.child('game/firstShotsDone/' + mySlot).set(true);

                // Check if all players have taken first shot
                const updatedFirstShots = { ...mpFirstShotsDone, [mySlot]: true };
                const allDone = turnOrder.every(s => updatedFirstShots[s]);

                if (allDone) {
                    // Check if everyone holed out during first shots
                    const allHoledFirst = turnOrder.every(s => {
                        if (s === mySlot) return holedOut;
                        return mpPlayerStates[s] && mpPlayerStates[s].holedOut;
                    });
                    if (allHoledFirst) {
                        const scorecardUpdate = {};
                        turnOrder.forEach(slot => {
                            const st = slot === mySlot ? strokes : (mpPlayerStates[slot] || {}).strokes || 0;
                            const existing = mpScorecard[slot] || [];
                            scorecardUpdate[slot] = [...existing, st];
                        });
                        currentLobby.child('game/scorecard').set(scorecardUpdate);
                        currentLobby.child('game/holeComplete').set(Date.now());
                    } else {
                        const nextShooter = determineFurthestFromHole();
                        currentLobby.child('game').update({
                            phase: 'furthestFirst',
                            turn: nextShooter
                        });
                    }
                } else {
                    advanceToNextFirstShot();
                }
            } else {
                // furthestFirst phase
                // Check if all holed out
                const allHoled = turnOrder.every(s => {
                    if (s === mySlot) return holedOut;
                    return mpPlayerStates[s] && mpPlayerStates[s].holedOut;
                });

                if (allHoled) {
                    // Record scores to scorecard
                    const scorecardUpdate = {};
                    turnOrder.forEach(slot => {
                        const st = slot === mySlot ? strokes : (mpPlayerStates[slot] || {}).strokes || 0;
                        const existing = mpScorecard[slot] || [];
                        scorecardUpdate[slot] = [...existing, st];
                    });
                    currentLobby.child('game/scorecard').set(scorecardUpdate);
                    // Signal all players to show scorecard
                    currentLobby.child('game/holeComplete').set(Date.now());
                } else {
                    const nextShooter = determineFurthestFromHole();
                    currentLobby.child('game/turn').set(nextShooter);
                }
            }
        }

        function advanceToNextFirstShot() {
            const currentIdx = turnOrder.indexOf(mySlot);
            for (let i = 1; i <= turnOrder.length; i++) {
                const nextSlot = turnOrder[(currentIdx + i) % turnOrder.length];
                if (!mpFirstShotsDone[nextSlot]) {
                    currentLobby.child('game/turn').set(nextSlot);
                    return;
                }
            }
            // All done ‚Äî transition
            const nextShooter = determineFurthestFromHole();
            currentLobby.child('game').update({
                phase: 'furthestFirst',
                turn: nextShooter
            });
        }

        function determineFurthestFromHole() {
            let maxDist = -1;
            let furthest = turnOrder[0];
            const hx = currentHole.holePos.x;
            const hy = currentHole.holePos.y;

            turnOrder.forEach(slot => {
                const state = mpPlayerStates[slot];
                if (!state || state.holedOut) return;
                const bx = (allPlayerBalls[slot] && allPlayerBalls[slot].x) || state.ballX || 0;
                const by = (allPlayerBalls[slot] && allPlayerBalls[slot].y) || state.ballY || 0;
                const dist = Math.sqrt((bx - hx) ** 2 + (by - hy) ** 2);
                if (dist > maxDist) {
                    maxDist = dist;
                    furthest = slot;
                }
            });

            return furthest;
        }

        // Draw all player balls
        function drawAllPlayerBalls() {
            if (!isMultiplayer) return;
            turnOrder.forEach(slot => {
                if (slot === mySlot && isMyTurn) return; // My ball drawn normally when it's my turn
                if (slot === replayingSlot) return; // Don't draw resting pos while replaying their shot
                const pb = allPlayerBalls[slot];
                const state = mpPlayerStates[slot];
                if (!pb || pb.holedOut) return;
                if (!pb.x && !pb.y) return;
                if (!state) return;

                ctx.save();

                // Draw ball with their cosmetic
                const r = BALL_BASE_RADIUS;
                const ballType = state.activeBall || 'default';
                if (ballType === 'diamondBall') {
                    const grd = ctx.createRadialGradient(pb.x - r * 0.3, pb.y - r * 0.35, r * 0.1, pb.x, pb.y, r);
                    grd.addColorStop(0, '#FFFFFF'); grd.addColorStop(0.3, '#E0F0FF');
                    grd.addColorStop(0.6, '#A0D8FF'); grd.addColorStop(1, '#6BB8E8');
                    ctx.fillStyle = grd;
                } else if (ballType === 'goldBall') {
                    const grd = ctx.createRadialGradient(pb.x - r * 0.3, pb.y - r * 0.35, r * 0.1, pb.x, pb.y, r);
                    grd.addColorStop(0, '#FFF6A0'); grd.addColorStop(0.4, '#FFD700'); grd.addColorStop(1, '#B8860B');
                    ctx.fillStyle = grd;
                } else if (ballType === 'eightBall') {
                    ctx.fillStyle = '#111';
                } else if (ballType === 'camoBall') {
                    ctx.fillStyle = '#556B2F';
                } else {
                    ctx.fillStyle = 'white';
                }
                ctx.beginPath();
                ctx.arc(pb.x, pb.y, r, 0, Math.PI * 2);
                ctx.fill();

                // Name label only (no ring)
                ctx.fillStyle = SLOT_COLORS[slot];
                ctx.font = "bold 9px 'Cormorant Garamond', serif";
                ctx.textAlign = 'center';
                ctx.fillText(getMpPlayerNameBySlot(slot), pb.x, pb.y - r - 6);
                ctx.restore();
            });
        }

        // Scorecard
        function showMpScorecard() {
            const body = document.getElementById('mpScorecardBody');
            const title = document.getElementById('mpScorecardTitle');
            const isLastHole = mpCurrentHoleIndex >= holes.length - 1;

            title.textContent = isLastHole ? 'FINAL STANDINGS' : `HOLE ${mpCurrentHoleIndex + 1} COMPLETE`;

            // Build scorecard table
            const completedHoles = (mpScorecard[turnOrder[0]] || []).length;
            let html = '<table class="mp-scorecard"><thead><tr><th style="text-align:left;">PLAYER</th>';
            for (let h = 0; h < completedHoles; h++) {
                html += `<th>${h + 1}</th>`;
            }
            html += '<th>TOT</th><th>¬±PAR</th></tr></thead><tbody>';

            // Par row
            html += '<tr class="par-row"><td style="text-align:left; color:#888;">PAR</td>';
            let totalParForCard = 0;
            for (let h = 0; h < completedHoles; h++) {
                const holePar = holes[h].par;
                totalParForCard += holePar;
                html += `<td>${holePar}</td>`;
            }
            html += `<td>${totalParForCard}</td><td></td></tr>`;

            // Player rows
            function escHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
            turnOrder.forEach(slot => {
                const name = escHtml(getMpPlayerNameBySlot(slot));
                const scores = mpScorecard[slot] || [];
                let total = 0;
                html += `<tr class="player-row"><td style="text-align:left;"><span style="color:${SLOT_COLORS[slot]}">‚óè</span> ${name}</td>`;
                for (let h = 0; h < completedHoles; h++) {
                    const s = scores[h] || 0;
                    total += s;
                    const holePar = holes[h].par;
                    const cls = s < holePar ? 'under-par' : (s > holePar ? 'over-par' : '');
                    const bold = h === completedHoles - 1 ? 'font-weight:bold;' : '';
                    html += `<td class="${cls}" style="${bold}">${s}</td>`;
                }
                const toPar = total - totalParForCard;
                const toParStr = toPar === 0 ? 'E' : (toPar > 0 ? '+' + toPar : '' + toPar);
                const toParCls = toPar < 0 ? 'under-par' : (toPar > 0 ? 'over-par' : 'even-par');
                html += `<td style="font-weight:bold;">${total}</td>`;
                html += `<td class="${toParCls}" style="font-weight:bold;">${toParStr}</td></tr>`;
            });

            html += '</tbody></table>';
            body.innerHTML = html;

            // Show/hide buttons
            document.getElementById('mpNextHoleBtn').style.display = isLastHole ? 'none' : 'block';
            document.getElementById('mpReturnMenuBtn').style.display = 'block';

            document.getElementById('mpScorecardOverlay').style.display = 'block';
            document.getElementById('mpScorecardOverlay').classList.add('show');
        }

        document.getElementById('mpNextHoleBtn').addEventListener('click', () => {
            document.getElementById('mpScorecardOverlay').classList.remove('show');
            document.getElementById('mpScorecardOverlay').style.display = 'none';

            if (mySlot === 'p1') {
                const nextHole = mpCurrentHoleIndex + 1;
                const resetStates = {};
                const resetFirstShots = {};
                turnOrder.forEach(slot => {
                    resetStates[slot] = {
                        ballX: 0, ballY: 0, strokes: 0,
                        holedOut: false,
                        activeBall: (mpPlayerStates[slot] || {}).activeBall || 'default',
                        selectedClub: 'driver'
                    };
                    resetFirstShots[slot] = false;
                });

                // New random wind for next hole
                const newWindDir = Math.random() < 0.5 ? -1 : 1;
                const newWindStr = 0.2 + Math.random() * 0.8;

                currentLobby.child('game').update({
                    currentHole: nextHole,
                    phase: 'firstShots',
                    firstShotsDone: resetFirstShots,
                    playerStates: resetStates,
                    turn: turnOrder[0],
                    currentTurnIndex: 0,
                    balls: null,
                    shot: null,
                    holeComplete: null,
                    wind: { direction: newWindDir, strength: newWindStr }
                });
            }
        });

        document.getElementById('mpReturnMenuBtn').addEventListener('click', () => {
            document.getElementById('mpScorecardOverlay').classList.remove('show');
            document.getElementById('mpScorecardOverlay').style.display = 'none';
            cleanupMpGame();
            cleanupMpLobby();
            returnToMenu();
        });

        // Disconnect handling
        function handleMpPlayerDisconnects() {
            if (!isMultiplayer || !currentLobby) return;
            const connected = Object.values(lobbyPlayers).filter(p => p.connected);
            const connectedSlots = connected.map(p => p.slot);

            // Remove disconnected slots from turn order
            const disconnectedSlots = turnOrder.filter(s => !connectedSlots.includes(s));
            if (disconnectedSlots.length === 0) return;

            const newTurnOrder = turnOrder.filter(s => connectedSlots.includes(s));
            if (newTurnOrder.length < 1) return;

            // Only host handles cleanup
            if (mySlot === 'p1') {
                const currentTurnSlot = turnOrder[currentTurnIndex];
                let newTurn = currentTurnSlot;
                if (disconnectedSlots.includes(currentTurnSlot)) {
                    newTurn = newTurnOrder[0] || turnOrder[0];
                }

                currentLobby.child('game').update({
                    turnOrder: newTurnOrder,
                    turn: newTurn,
                    currentTurnIndex: newTurnOrder.indexOf(newTurn)
                });
            }
            turnOrder = newTurnOrder;
        }

        // Cleanup
        function cleanupMpGame() {
            for (const listener of mpListeners) {
                if (listener.ref) listener.ref.off(listener.event);
            }
            mpListeners = [];
            isMultiplayer = false;
            isMyTurn = false;
            mpPlayerStates = {};
            allPlayerBalls = {};
            mpScorecard = {};
            mpFirstShotsDone = {};
            document.getElementById('mpHUD').style.display = 'none';
            document.getElementById('mpReactionBar').style.display = 'none';
        }

        function cleanupMpLobby() {
            for (const l of lobbyRoomListeners) { l.ref.off(l.event); }
            lobbyRoomListeners = [];
            if (lobbyBrowserRef) { lobbyBrowserRef.off('value'); lobbyBrowserRef = null; }
            if (currentLobby && myPlayerId) {
                currentLobby.child('players/' + myPlayerId + '/connected').onDisconnect().cancel();
                if (mySlot === 'p1') {
                    currentLobby.child('status').onDisconnect().cancel();
                }
                // Mark disconnected
                currentLobby.child('players/' + myPlayerId + '/connected').set(false);
                const count = Object.values(lobbyPlayers).filter(p => p.connected && p.slot !== mySlot).length;
                currentLobby.child('playerCount').set(Math.max(0, count));
            }
            currentLobby = null;
            currentLobbyId = null;
            myPlayerId = null;
            mySlot = null;
            lobbyPlayers = {};
            turnOrder = [];
        }

        // ==================== START ====================
        init();
    </script>
</body>
</html>
