<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roughest Demo Tapes 3</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow-x: hidden; }
        @keyframes redPulse {
            0%, 100% { box-shadow: 0 0 4px rgba(200,50,50,0.3); }
            50% { box-shadow: 0 0 16px rgba(200,50,50,0.8), 0 0 24px rgba(200,50,50,0.3); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        const FONT = "'Playfair Display', serif";
        const RED = '#cc3333';
        const BG = '#87CEEB';

        // Custom Vertical Slider — label ON the handle
        const VerticalSlider = ({ value, min, max, step, onChange, height, label, disabled }) => {
            const trackRef = useRef(null);
            const pct = Math.max(0, Math.min(100, ((value - min) / (max - min)) * 100));

            const getVal = (clientY) => {
                if (!trackRef.current) return value;
                const rect = trackRef.current.getBoundingClientRect();
                const ratio = 1 - Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));
                let v = min + ratio * (max - min);
                v = Math.round(v / step) * step;
                return Math.max(min, Math.min(max, parseFloat(v.toFixed(6))));
            };

            const startDrag = (startY) => {
                if (disabled) return;
                onChange(getVal(startY));
                const onMove = (e) => {
                    e.preventDefault();
                    const y = e.touches ? e.touches[0].clientY : e.clientY;
                    onChange(getVal(y));
                };
                const onEnd = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('touchend', onEnd);
            };

            return (
                <div style={{
                    width: 60, height, position: 'relative',
                    flexShrink: 0, flexGrow: 0
                }}>
                    <div ref={trackRef}
                        style={{
                            width: 4, height: '100%', background: '#000',
                            position: 'absolute', left: '50%', top: 0,
                            transform: 'translateX(-50%)',
                            cursor: disabled ? 'default' : 'pointer',
                            opacity: disabled ? 0.5 : 1, touchAction: 'none'
                        }}
                        onMouseDown={(e) => { e.preventDefault(); startDrag(e.clientY); }}
                        onTouchStart={(e) => { e.preventDefault(); startDrag(e.touches[0].clientY); }}
                    >
                        {/* Handle with label */}
                        <div style={{
                            position: 'absolute',
                            bottom: `calc(${pct}% - 16px)`,
                            left: '50%',
                            transform: 'translateX(-50%)',
                            width: 56, height: 32,
                            background: RED,
                            animation: disabled ? 'none' : 'redPulse 2s ease-in-out infinite',
                            cursor: disabled ? 'default' : 'grab',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                        }}>
                            <span style={{
                                color: '#000', fontSize: 13, fontWeight: 700,
                                fontFamily: FONT, letterSpacing: 1,
                                pointerEvents: 'none', userSelect: 'none'
                            }}>{label}</span>
                        </div>
                    </div>
                </div>
            );
        };

        function DJStand() {
            // Audio state
            const [isPlaying, setIsPlaying] = useState(false);
            const [speed, setSpeed] = useState(1.0);
            const [distortion, setDistortion] = useState(0);
            const [reverb, setReverb] = useState(0);
            const [lpf, setLpf] = useState(100);
            const [masterVol, setMasterVol] = useState(80);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [tracks] = useState([
                { name: 'Sure Is Cold', url: 'sureiscoldroughmaster.m4a' },
                { name: 'Carolina Curveball', url: 'carolinacurveballroughmaster.m4a' },
                { name: 'Yellow Pine', url: 'yellopineroughmaster.m4a' },
                { name: 'Time', url: 'timeroughmaster.m4a' },
                { name: 'Divorced', url: 'divorcedroughymaster.m4a' },
                { name: 'U Don\'t (Wedding)', url: 'udont_weddingroughmaster.m4a' },
                { name: 'Memphis', url: 'newmemphismix.m4a' }
            ]);
            const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);
            const [trackLoaded, setTrackLoaded] = useState(false);
            const [loading, setLoading] = useState(false);

            // Audio refs
            const audioContextRef = useRef(null);
            const audioBufferRef = useRef(null);
            const sourceNodeRef = useRef(null);
            const analyserRef = useRef(null);
            const distortionNodeRef = useRef(null);
            const gainNodeRef = useRef(null);
            const lpfNodeRef = useRef(null);
            const reverbConvolverRef = useRef(null);
            const reverbWetGainRef = useRef(null);
            const reverbDryGainRef = useRef(null);
            const canvasRef = useRef(null);
            const animationRef = useRef(null);
            const initRef = useRef(false);
            const timeIntervalRef = useRef(null);

            // Playback position tracking
            const playbackOffsetRef = useRef(0);
            const contextStartTimeRef = useRef(0);
            const speedRef = useRef(1.0);
            const isPlayingRef = useRef(false);
            const currentTrackIndexRef = useRef(-1);

            // Fullscreen
            const [isFullscreen, setIsFullscreen] = useState(false);

            // Game meters
            const [gameFocus, setGameFocus] = useState(null);
            const [gameFun, setGameFun] = useState(null);
            const [gameMode, setGameMode] = useState(false);

            // Generate impulse response for convolution reverb
            const generateImpulseResponse = (ctx, dur = 2, decay = 2) => {
                const length = ctx.sampleRate * dur;
                const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                    }
                }
                return impulse;
            };

            // Compute all effects from game meters
            // FUN range: max 200% speed (was 250%), min 10% below old floor (0.54x vs 0.6x)
            const computeFromMeters = (focus, fun) => {
                const computedSpeed = Math.min(2.0, 0.54 + (focus / 100 * 0.36) + (fun / 100 * 1.1));
                const computedDirt = Math.min(100, (focus / 100 * 25) + Math.min(75, fun / 60 * 75));
                const computedReverb = Math.min(60, fun / 100 * 60);
                const lpfFreq = 20000 - (fun / 100 * 15000);
                const computedLpf = Math.max(0, Math.min(100, Math.log(lpfFreq / 200) / Math.log(100) * 100));
                return { speed: computedSpeed, dirt: computedDirt, reverb: computedReverb, lpf: computedLpf };
            };

            // LPF slider (0-100) to frequency (200-20000 Hz) logarithmic mapping
            const lpfToFreq = (val) => 200 * Math.pow(100, val / 100);

            const getCurrentPosition = () => {
                if (!isPlayingRef.current || !audioContextRef.current) return playbackOffsetRef.current;
                const elapsed = audioContextRef.current.currentTime - contextStartTimeRef.current;
                return playbackOffsetRef.current + elapsed * speedRef.current;
            };

            // Initialize Web Audio API — full chain
            useEffect(() => {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                audioContextRef.current = ctx;

                analyserRef.current = ctx.createAnalyser();
                analyserRef.current.fftSize = 2048;
                distortionNodeRef.current = ctx.createWaveShaper();
                gainNodeRef.current = ctx.createGain();
                gainNodeRef.current.gain.value = 0.8;

                lpfNodeRef.current = ctx.createBiquadFilter();
                lpfNodeRef.current.type = 'lowpass';
                lpfNodeRef.current.frequency.value = 20000;

                reverbConvolverRef.current = ctx.createConvolver();
                reverbConvolverRef.current.buffer = generateImpulseResponse(ctx);
                reverbWetGainRef.current = ctx.createGain();
                reverbWetGainRef.current.gain.value = 0;
                reverbDryGainRef.current = ctx.createGain();
                reverbDryGainRef.current.gain.value = 1;

                lpfNodeRef.current.connect(distortionNodeRef.current);
                distortionNodeRef.current.connect(reverbDryGainRef.current);
                reverbDryGainRef.current.connect(analyserRef.current);
                distortionNodeRef.current.connect(reverbConvolverRef.current);
                reverbConvolverRef.current.connect(reverbWetGainRef.current);
                reverbWetGainRef.current.connect(analyserRef.current);
                analyserRef.current.connect(gainNodeRef.current);
                gainNodeRef.current.connect(ctx.destination);

                return () => {
                    if (animationRef.current) cancelAnimationFrame(animationRef.current);
                    if (timeIntervalRef.current) clearInterval(timeIntervalRef.current);
                    ctx.close();
                };
            }, []);

            // Auto-load random track and attempt autoplay
            useEffect(() => {
                if (!initRef.current && tracks.length > 0) {
                    initRef.current = true;
                    const randIdx = Math.floor(Math.random() * tracks.length);
                    loadTrackByIndex(randIdx, true);
                }
            }, []);

            // Time display updater
            useEffect(() => {
                if (isPlaying) {
                    timeIntervalRef.current = setInterval(() => {
                        setCurrentTime(Math.min(getCurrentPosition(), duration));
                    }, 80);
                } else {
                    if (timeIntervalRef.current) clearInterval(timeIntervalRef.current);
                }
                return () => { if (timeIntervalRef.current) clearInterval(timeIntervalRef.current); };
            }, [isPlaying, duration]);

            // Apply game meters
            useEffect(() => {
                if (gameMode && gameFocus !== null && gameFun !== null) {
                    const { speed, dirt, reverb, lpf } = computeFromMeters(gameFocus, gameFun);
                    setSpeedDirect(speed);
                    setDistortionDirect(dirt);
                    setReverbDirect(reverb);
                    setLpfDirect(lpf);
                }
            }, [gameMode, gameFocus, gameFun]);

            const startPlayback = () => {
                if (!audioBufferRef.current || !audioContextRef.current) return;
                if (audioContextRef.current.state === 'suspended') audioContextRef.current.resume();

                const source = audioContextRef.current.createBufferSource();
                source.buffer = audioBufferRef.current;
                source.playbackRate.value = speedRef.current;
                source.connect(lpfNodeRef.current);

                source.onended = () => {
                    if (sourceNodeRef.current === source) {
                        isPlayingRef.current = false;
                        setIsPlaying(false);
                        playbackOffsetRef.current = 0;
                        setCurrentTime(0);
                        autoAdvance();
                    }
                };

                const offset = Math.max(0, Math.min(playbackOffsetRef.current, audioBufferRef.current.duration - 0.01));
                source.start(0, offset);
                sourceNodeRef.current = source;
                contextStartTimeRef.current = audioContextRef.current.currentTime;
                isPlayingRef.current = true;
                setIsPlaying(true);
                drawWaveform();
            };

            const stopPlayback = () => {
                if (sourceNodeRef.current) {
                    const pos = getCurrentPosition();
                    sourceNodeRef.current.onended = null;
                    try { sourceNodeRef.current.stop(); } catch (e) {}
                    sourceNodeRef.current.disconnect();
                    sourceNodeRef.current = null;
                    playbackOffsetRef.current = pos;
                }
                isPlayingRef.current = false;
                if (animationRef.current) cancelAnimationFrame(animationRef.current);
            };

            const autoAdvance = () => {
                const idx = currentTrackIndexRef.current;
                if (tracks.length > 1) {
                    const nextIdx = (idx + 1) % tracks.length;
                    setTimeout(() => loadTrackByIndex(nextIdx), 100);
                }
            };

            const loadTrackByIndex = async (index, autoPlay = true) => {
                if (index < 0 || index >= tracks.length) return;
                stopPlayback();
                setLoading(true);
                setCurrentTrackIndex(index);
                currentTrackIndexRef.current = index;
                setTrackLoaded(false);
                playbackOffsetRef.current = 0;
                setCurrentTime(0);

                try {
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', tracks[index].url, true);
                        xhr.responseType = 'arraybuffer';
                        xhr.onload = () => {
                            if (xhr.status === 200 || xhr.status === 0) resolve(xhr.response);
                            else reject(new Error(`HTTP ${xhr.status}`));
                        };
                        xhr.onerror = () => reject(new Error('Failed to load audio file'));
                        xhr.send();
                    });

                    const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);
                    audioBufferRef.current = audioBuffer;
                    setDuration(audioBuffer.duration);
                    setTrackLoaded(true);
                    setLoading(false);

                    try { window.parent.postMessage({ type: 'trackChanged', name: tracks[index].name, index }, '*'); } catch(e) {}
                    if (autoPlay) startPlayback();
                } catch (err) {
                    console.error('Failed to load audio:', err);
                    setLoading(false);
                }
            };

            const makeDistortionCurve = (amount) => {
                const samples = 44100;
                const curve = new Float32Array(samples);
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = Math.tanh(x * (1 + amount / 10));
                }
                return curve;
            };

            const setSpeedDirect = (val) => {
                if (isPlayingRef.current) {
                    playbackOffsetRef.current = getCurrentPosition();
                    contextStartTimeRef.current = audioContextRef.current.currentTime;
                }
                speedRef.current = val;
                setSpeed(val);
                if (sourceNodeRef.current) sourceNodeRef.current.playbackRate.value = val;
            };

            const setDistortionDirect = (val) => {
                setDistortion(val);
                if (distortionNodeRef.current) {
                    distortionNodeRef.current.curve = makeDistortionCurve(val / 10);
                    distortionNodeRef.current.oversample = '4x';
                }
            };

            const setReverbDirect = (val) => {
                setReverb(val);
                if (reverbWetGainRef.current && reverbDryGainRef.current) {
                    reverbWetGainRef.current.gain.value = val / 100;
                    reverbDryGainRef.current.gain.value = 1 - (val / 100);
                }
            };

            const setLpfDirect = (val) => {
                setLpf(val);
                if (lpfNodeRef.current) {
                    lpfNodeRef.current.frequency.value = lpfToFreq(val);
                }
            };

            const setMasterDirect = (val) => {
                setMasterVol(val);
                if (gainNodeRef.current) gainNodeRef.current.gain.value = val / 100;
            };

            const drawWaveform = () => {
                if (!analyserRef.current || !canvasRef.current) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const bufferLength = analyserRef.current.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                const draw = () => {
                    animationRef.current = requestAnimationFrame(draw);
                    analyserRef.current.getByteTimeDomainData(dataArray);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.lineWidth = 2.5;
                    ctx.strokeStyle = RED;
                    ctx.beginPath();
                    const sliceWidth = canvas.width / bufferLength;
                    let x = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = (v * canvas.height) / 2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                        x += sliceWidth;
                    }
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.stroke();
                };
                draw();
            };

            const togglePlay = async () => {
                if (!trackLoaded) return;
                if (isPlayingRef.current) { stopPlayback(); setIsPlaying(false); }
                else startPlayback();
            };

            const skipTrack = (direction) => {
                if (tracks.length === 0) return;
                const newIndex = (currentTrackIndexRef.current + direction + tracks.length) % tracks.length;
                loadTrackByIndex(newIndex);
            };

            const resetControls = () => {
                setSpeedDirect(1.0);
                setDistortionDirect(0);
                setReverbDirect(0);
                setLpfDirect(100);
                setMasterDirect(80);
            };

            const toggleFullscreen = () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            };

            useEffect(() => {
                const onFsChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', onFsChange);
                return () => document.removeEventListener('fullscreenchange', onFsChange);
            }, []);

            // postMessage listener
            const commandHandlerRef = useRef(null);
            commandHandlerRef.current = (data) => {
                if (!data || !data.type) return;
                switch (data.type) {
                    case 'togglePlay': togglePlay(); break;
                    case 'play':
                        if (!isPlayingRef.current && trackLoaded) startPlayback();
                        break;
                    case 'pause':
                        if (isPlayingRef.current) { stopPlayback(); setIsPlaying(false); }
                        break;
                    case 'skipTrack': skipTrack(data.direction || 1); break;
                    case 'playRandom':
                        if (tracks.length > 0) {
                            const randIdx = Math.floor(Math.random() * tracks.length);
                            loadTrackByIndex(randIdx);
                        }
                        break;
                    case 'setGameMode':
                        setGameMode(!!data.enabled);
                        if (data.enabled) {
                            // Only update meters if explicitly provided (preserves song on mode toggle)
                            if (typeof data.focus === 'number') setGameFocus(data.focus);
                            if (typeof data.fun === 'number') setGameFun(data.fun);
                        } else {
                            setGameFocus(null);
                            setGameFun(null);
                            // Preserve speed, LPF, and master when switching to free mix
                            if (data.resetDefaults) {
                                setDistortionDirect(0);
                                setReverbDirect(0);
                            }
                        }
                        break;
                    case 'gameMeters':
                        if (typeof data.focus === 'number') setGameFocus(data.focus);
                        if (typeof data.fun === 'number') setGameFun(data.fun);
                        break;
                }
            };

            useEffect(() => {
                const onMessage = (e) => { if (commandHandlerRef.current) commandHandlerRef.current(e.data); };
                window.addEventListener('message', onMessage);
                return () => window.removeEventListener('message', onMessage);
            }, []);

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            return (
                <div style={{
                    minHeight: '100vh',
                    background: BG,
                    fontFamily: FONT,
                    padding: '20px 16px',
                    color: '#222'
                }}>
                    <div style={{ maxWidth: 400, margin: '0 auto' }}>

                        {/* Title */}
                        <div style={{ textAlign: 'center', marginBottom: 20 }}>
                            <h1 style={{
                                fontSize: 28, fontWeight: 700, fontStyle: 'italic',
                                color: '#000', margin: 0, lineHeight: 1.1
                            }}>
                                Roughest Demo<br/>Tapes 3
                            </h1>
                        </div>

                        {/* Waveform */}
                        <div style={{ background: '#000', padding: 4, marginBottom: 8 }}>
                            <canvas ref={canvasRef} width={836} height={50}
                                style={{ width: '100%', height: 'auto', display: 'block' }} />
                        </div>

                        {/* Now Playing */}
                        {(trackLoaded || loading) && tracks[currentTrackIndex] && (
                            <div style={{ textAlign: 'center', marginBottom: 12, fontSize: 13, color: '#333' }}>
                                <span style={{ color: RED, fontWeight: 700 }}>{tracks[currentTrackIndex].name}</span>
                                {' '}{formatTime(currentTime)} / {formatTime(duration)}
                            </div>
                        )}

                        {/* Transport Controls — offset upper-left */}
                        <div style={{
                            display: 'flex', gap: 8, justifyContent: 'flex-start', alignItems: 'center',
                            marginBottom: 16, paddingLeft: 4
                        }}>
                            {/* Skip Back — large triangle */}
                            <button onClick={() => skipTrack(-1)} disabled={tracks.length === 0}
                                style={{
                                    background: 'none', border: 'none', cursor: 'pointer',
                                    opacity: tracks.length > 0 ? 1 : 0.4, padding: 0
                                }}>
                                <svg width="80" height="70" viewBox="0 0 80 70">
                                    <polygon points="75,5 5,35 75,65" fill={RED} />
                                </svg>
                            </button>

                            {/* Play/Pause — circle with triangle */}
                            <button onClick={togglePlay} disabled={!trackLoaded}
                                style={{
                                    width: 80, height: 80,
                                    borderRadius: '50%',
                                    background: '#fff',
                                    border: `3px solid ${RED}`,
                                    cursor: trackLoaded ? 'pointer' : 'default',
                                    opacity: trackLoaded ? 1 : 0.5,
                                    display: 'flex', alignItems: 'center', justifyContent: 'center',
                                    padding: 0, flexShrink: 0
                                }}>
                                {isPlaying ? (
                                    <svg width="32" height="32" viewBox="0 0 24 24" fill={RED}>
                                        <rect x="6" y="4" width="4" height="16" />
                                        <rect x="14" y="4" width="4" height="16" />
                                    </svg>
                                ) : (
                                    <svg width="36" height="36" viewBox="0 0 24 24" fill={RED}>
                                        <polygon points="6 3 20 12 6 21 6 3" />
                                    </svg>
                                )}
                            </button>

                            {/* Skip Forward — large triangle */}
                            <button onClick={() => skipTrack(1)} disabled={tracks.length === 0}
                                style={{
                                    background: 'none', border: 'none', cursor: 'pointer',
                                    opacity: tracks.length > 0 ? 1 : 0.4, padding: 0
                                }}>
                                <svg width="80" height="70" viewBox="0 0 80 70">
                                    <polygon points="5,5 75,35 5,65" fill={RED} />
                                </svg>
                            </button>
                        </div>

                        {/* Vertical Faders — 4 small left + FUN large right */}
                        <div style={{
                            display: 'flex',
                            justifyContent: 'center',
                            alignItems: 'flex-end',
                            gap: 16,
                            marginBottom: 20,
                            padding: '0 8px'
                        }}>
                            {/* Left group: MSTR, Verb, Dirt, LPF */}
                            <div style={{ display: 'flex', gap: 16, alignItems: 'flex-end' }}>
                                <VerticalSlider
                                    value={masterVol} min={0} max={100} step={1}
                                    onChange={(v) => setMasterDirect(v)}
                                    height={320} label="MSTR"
                                    disabled={false}
                                />
                                <VerticalSlider
                                    value={reverb} min={0} max={100} step={1}
                                    onChange={(v) => !gameMode && setReverbDirect(v)}
                                    height={320} label="Verb"
                                    disabled={gameMode}
                                />
                                <VerticalSlider
                                    value={distortion} min={0} max={100} step={1}
                                    onChange={(v) => !gameMode && setDistortionDirect(v)}
                                    height={320} label="Dirt"
                                    disabled={gameMode}
                                />
                                <VerticalSlider
                                    value={lpf} min={0} max={100} step={1}
                                    onChange={(v) => !gameMode && setLpfDirect(v)}
                                    height={320} label="LPF"
                                    disabled={gameMode}
                                />
                            </div>

                            {/* FUN (Speed/Pitch) — tallest, on the right */}
                            <VerticalSlider
                                value={speed} min={0.54} max={2.0} step={0.01}
                                onChange={(v) => !gameMode && setSpeedDirect(v)}
                                height={560} label="FUN"
                                disabled={gameMode}
                            />
                        </div>

                        {/* Reset button */}
                        <div style={{ textAlign: 'center', marginBottom: 16 }}>
                            <button onClick={resetControls}
                                style={{
                                    background: RED, border: 'none', color: '#fff',
                                    padding: '10px 28px', fontSize: 14, fontWeight: 700,
                                    fontFamily: FONT, letterSpacing: 2, cursor: 'pointer',
                                    animation: 'redPulse 2s ease-in-out infinite'
                                }}>
                                RESET
                            </button>
                        </div>

                        {/* Playlist */}
                        {tracks.length > 0 && (
                            <div style={{ background: 'rgba(0,0,0,0.06)', padding: 12, marginBottom: 12, maxHeight: 180, overflowY: 'auto' }}>
                                <div style={{ fontSize: 10, color: '#555', letterSpacing: 2, textAlign: 'center', marginBottom: 6 }}>
                                    PLAYLIST
                                </div>
                                {tracks.map((track, index) => (
                                    <div key={index}
                                        style={{
                                            display: 'flex', alignItems: 'center', gap: 8,
                                            padding: '5px 8px', marginBottom: 2, cursor: 'pointer',
                                            background: index === currentTrackIndex ? 'rgba(200,50,50,0.15)' : 'transparent',
                                            border: index === currentTrackIndex ? `1px solid ${RED}` : '1px solid transparent'
                                        }}
                                        onClick={() => loadTrackByIndex(index)}
                                    >
                                        <span style={{
                                            flex: 1, fontSize: 13,
                                            color: index === currentTrackIndex ? RED : '#333',
                                            fontWeight: index === currentTrackIndex ? 700 : 400
                                        }}>
                                            {track.name}
                                        </span>
                                        {index === currentTrackIndex && isPlaying && (
                                            <span style={{ fontSize: 9, color: RED, letterSpacing: 1 }}>PLAYING</span>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}

                        {/* Footer */}
                        <div style={{ textAlign: 'center', marginTop: 12, fontSize: 10, color: '#555', letterSpacing: 2 }}>
                            BOTTOM SHELF
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DJStand />);
    </script>
</body>
</html>
